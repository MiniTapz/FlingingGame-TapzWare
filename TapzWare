local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

print("LocalPlayer found:", LocalPlayer.Name)

-- Wait for character
if not LocalPlayer.Character then
    LocalPlayer.CharacterAdded:Wait()
end
print("Character found:", LocalPlayer.Character.Name)

-- Load UI Library
print("Loading UI Library...")
local success, library = pcall(function()
    return loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)()
end)

if not success then
    warn("Failed to load UI library:", library)
    return
end

print("UI Library loaded successfully!")
local Wait = library.subs.Wait

-- Force third person camera
LocalPlayer.CameraMode = Enum.CameraMode.Classic
LocalPlayer.CameraMaxZoomDistance = 128
LocalPlayer.CameraMinZoomDistance = 12 -- Set to 12 first to force third person
task.wait(0.1) -- Brief delay
LocalPlayer.CameraMinZoomDistance = 0.5 -- Then back to 0.5 to allow full zoom

-- Fling Settings
local FLING_POWER = 500
local instantFlingEnabled = false
local auraEnabled = false
local AURA_RADIUS = 15

-- Target System
local targetEnabled = false
local autoTargetEnabled = false -- Auto-select closest player
local targetPlayer = nil
local TARGET_MAX_DISTANCE = 1500 -- Maximum distance to start following
local TARGET_STOP_DISTANCE = 25 -- Distance to stop tweening at
local TARGET_TWEEN_SPEED = 50 -- Speed in studs per second
local targetTween = nil
local targetConnection = nil

-- Map Bounds System
local MAP_BOUNDS_ENABLED = true
local MAP_BOUNDS_CENTER = Vector3.new(27.173, 119.848, 50.196)
local MAP_BOUNDS_SIZE = Vector3.new(1433.347, 739.603, 1488.309)
local returningToSpawn = false

-- Auto Trash Talk System
local trashTalkEnabled = false
local trashTalkOnKill = true
local trashTalkOnFling = true
local trashTalkDelay = 3 -- Seconds between messages

-- Auto Spam Trash Talk (independent system)
local autoSpamTrashTalk = false
local autoSpamFrequency = 5 -- Seconds between auto messages
local lastAutoSpam = 0

local trashTalkMessages = {
    -- Kill messages (Roblox-safe, no harsh language)
    kill = {
        "gg #TapzWare!",
        "ez win #TapzWare!",
        "outplayed #TapzWare!",
        "too quick #TapzWare!",
        "better luck next time #TapzWare!",
        "gg wp #TapzWare!",
        "nice try #TapzWare!",
        "almost had me #TapzWare!",
        "got you #TapzWare!",
        "rekt #TapzWare!",
        "clapped #TapzWare!",
        "demolished #TapzWare!",
        "dominated #TapzWare!",
        "not even close #TapzWare!",
        "that was fast #TapzWare!",
        "wp to me #TapzWare!",
        "gg2ez #TapzWare!",
        "simply better #TapzWare!",
        "different league #TapzWare!",
        "skill gap #TapzWare!",
        "you tried your best #TapzWare!",
        "gg no re #TapzWare!",
        "sent #TapzWare!",
        "handled #TapzWare!",
        "wrapped up #TapzWare!"
    },
    -- Fling messages  
    fling = {
        "enjoy the flight #TapzWare!",
        "bon voyage #TapzWare!",
        "see you in orbit #TapzWare!",
        "fly high #TapzWare!",
        "to the moon #TapzWare!",
        "launched #TapzWare!",
        "blasted off #TapzWare!",
        "yeet #TapzWare!",
        "sent to space #TapzWare!",
        "flying lesson #TapzWare!",
        "farewell #TapzWare!",
        "have a nice trip #TapzWare!",
        "airmail #TapzWare!",
        "package delivered #TapzWare!",
        "express shipping #TapzWare!",
        "gone #TapzWare!",
        "blast off #TapzWare!",
        "rocket launch #TapzWare!",
        "up up and away #TapzWare!",
        "enjoy zero gravity #TapzWare!"
    },
    -- Auto spam messages (general trash talk, Roblox-safe)
    spam = {
        -- TapzWare promotion messages
        "#TapzWare on top!",
        "#TapzWare for the win!",
        "#TapzWare undefeated!",
        "powered by #TapzWare!",
        "#TapzWare supremacy!",
        "running #TapzWare!",
        "#TapzWare built different!",
        "get #TapzWare!",
        "#TapzWare domination!",
        "#TapzWare ftw!",
        
        -- Skill-based (safe)
        "too easy #TapzWare!",
        "built different #TapzWare!",
        "simply better #TapzWare!",
        "not even close #TapzWare!",
        "different level #TapzWare!",
        "skill gap real #TapzWare!",
        "untouchable #TapzWare!",
        "unbeatable #TapzWare!",
        "unstoppable force #TapzWare!",
        "cant be stopped #TapzWare!",
        "on another level #TapzWare!",
        "too strong #TapzWare!",
        "just warming up #TapzWare!",
        "havent even tried yet #TapzWare!",
        "this is light work #TapzWare!",
        
        -- Competitive (safe)
        "gg ez #TapzWare!",
        "gg wp #TapzWare!",
        "gg no re #TapzWare!",
        "good game #TapzWare!",
        "too quick #TapzWare!",
        "speed demon #TapzWare!",
        "lightning fast #TapzWare!",
        "quick work #TapzWare!",
        
        -- Confident (safe)
        "this is my game #TapzWare!",
        "this is my lobby #TapzWare!",
        "i own this server #TapzWare!",
        "king of the server #TapzWare!",
        "nobody can stop me #TapzWare!",
        "unmatched #TapzWare!",
        "peak performance #TapzWare!",
        "at my best #TapzWare!",
        "in my zone #TapzWare!",
        "locked in #TapzWare!",
        
        -- Playful (safe)
        "yall done yet? #TapzWare!",
        "anyone else? #TapzWare!",
        "whos next? #TapzWare!",
        "bring it on #TapzWare!",
        "is that all? #TapzWare!",
        "barely broke a sweat #TapzWare!",
        "warm up complete #TapzWare!",
        "stretching done #TapzWare!",
        "now its getting fun #TapzWare!",
        
        -- Motivational/Backhanded (safe)
        "nice try yall #TapzWare!",
        "better luck next time #TapzWare!",
        "you almost had it #TapzWare!",
        "so close #TapzWare!",
        "good attempt #TapzWare!",
        "keep trying #TapzWare!",
        "practice makes perfect #TapzWare!",
        "youll get there #TapzWare!",
        
        -- Simple flex (safe)
        "W #TapzWare!",
        "huge W #TapzWare!",
        "massive W #TapzWare!",
        "clean #TapzWare!",
        "smooth #TapzWare!",
        "perfect #TapzWare!",
        "flawless #TapzWare!",
        "immaculate #TapzWare!",
        "pristine #TapzWare!",
        
        -- Domination (safe)
        "dominating #TapzWare!",
        "on fire #TapzWare!",
        "unstoppable #TapzWare!",
        "on a streak #TapzWare!",
        "cant miss #TapzWare!",
        "perfect game #TapzWare!",
        "not losing today #TapzWare!",
        "undefeated #TapzWare!",
        
        -- Questions (safe, rhetorical)
        "too easy? #TapzWare!",
        "whos better? #TapzWare!",
        "anyone close? #TapzWare!",
        "any competition? #TapzWare!",
        "where the challenge? #TapzWare!",
        
        -- Game-specific (safe)
        "cleaned up #TapzWare!",
        "wiped the floor #TapzWare!",
        "swept the lobby #TapzWare!",
        "ran through yall #TapzWare!",
        "no contest #TapzWare!",
        "no competition #TapzWare!",
        "solo carry #TapzWare!",
        "1v everyone #TapzWare!",
        
        -- Casual flex (safe)
        "yawn #TapzWare!",
        "casual day #TapzWare!",
        "just another win #TapzWare!",
        "routine victory #TapzWare!",
        "easy mode #TapzWare!",
        "tutorial difficulty #TapzWare!",
        "practice lobby #TapzWare!",
        "warmup game #TapzWare!"
    }
}

local lastTrashTalk = 0

-- Aura visualization settings
local showAuraVisualization = true
local auraRingColor = Color3.fromRGB(255, 0, 127)
local auraRingThickness = 0.5
local auraRingHeight = 0.3
local auraRingSpin = false
local auraSpinSpeed = 1
local auraRingStyle = "dots" -- "dots" or "solid"
local currentRotation = 0

-- Aura system variables (declared early to prevent nil errors)
local auraRingParts = {}
local auraConnection = nil

-- KillAura Settings (COMPLETELY SEPARATE)
local killAuraEnabled = false
local KILLAURA_RADIUS = 15
local KILLAURA_VOID_Y = -10000 -- Extremely deep void for reliable kills
local KILLAURA_DELAY = 1.5 -- Longer delay to ensure death
local KILLAURA_BASE_VELOCITY = 50000 -- Base slam velocity
local KILLAURA_SPIKE_VELOCITY = 100000 -- Nuclear spike velocity
local killAuraConnection = nil
local recentlyKilled = {}

-- KillAura visualization settings
local showKillAuraVisualization = true
local killAuraRingColor = Color3.fromRGB(255, 0, 0)
local killAuraRingThickness = 0.5
local killAuraRingHeight = 0.3
local killAuraRingSpin = false
local killAuraSpinSpeed = 1
local killAuraRingStyle = "dots"
local killAuraCurrentRotation = 0
local killAuraRingParts = {}

-- Walkspeed variables
local customWalkspeedEnabled = false
local walkspeedValue = 16
local antiSlideEnabled = true -- Always enabled with custom walkspeed

-- Air control variable
local airControlEnabled = false

-- Noclip variable
local noclipEnabled = false
local noclipConnection = nil

-- Bhop variables
local bhopEnabled = false
local bhopType = "advanced" -- "advanced" or "simple" or "lowhop"
local baseSpeed = 20
local speedCap = 70
local currSpeed = baseSpeed
local lastDir = Vector3.new(0, 0, 0)
local bhopJumpBoost = 2.0 -- Multiplier for jump speed boost (Advanced mode only)
local lowHopJumpHeight = 3 -- Jump height for LowHop mode
local bhopFallSpeed = 50 -- Fall speed for LowHop mode

-- Infinite Jump variable
local infiniteJumpEnabled = false
local infiniteJumpPower = 50 -- Power of infinite jumps

-- Auto Strafe variables
local autoStrafeEnabled = false
local autoStrafeIntensity = 1 -- Speed of rotation (1-10)
local autoStrafeAngle = 0 -- Current angle for circular motion
local autoStrafeAnchor = nil -- The center point to circle around
local autoStrafeAnchorPart = nil -- Visible part for debugging
local autoStrafeRadius = 5 -- Distance from anchor to circle around

-- Force Shift Lock variable
local forceShiftLockEnabled = false

-- Wait for the grab events
print("Waiting for GrabEvents...")
local GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents", 10)
if not GrabEvents then
    warn("GrabEvents not found! This game may not have grab mechanics.")
else
    print("GrabEvents found!")
end

local CreateGrabLine = GrabEvents and GrabEvents:WaitForChild("CreateGrabLine", 5)
if CreateGrabLine then
    print("CreateGrabLine found!")
else
    warn("CreateGrabLine not found!")
end

-- Create Window
print("Creating UI Window...")
local FlingWindow = library:CreateWindow({
    Name = "TapzWare",
    Themeable = {
        Info = "Fling Script"
    }
})
print("UI Window created! Press RightShift to toggle menu")

-- ============================================
-- PLACEHOLDER FUNCTIONS (defined properly later)
-- ============================================
-- These prevent nil errors in callbacks
local updateAllESP = function() end
local createPlayerESP = function() end
local removePlayerESP = function() end
local update3DBox = function() end
local updateAuraRing = function() end
local createAuraRing = function() end
local createAura = function() end
local destroyAura = function() end
local updateKillAuraRing = function() end
local createKillAuraRing = function() end
local createKillAura = function() end
local destroyKillAura = function() end

-- Create Tabs
local FlingTab = FlingWindow:CreateTab({
    Name = "Fling"
})

local KillAuraTab = FlingWindow:CreateTab({
    Name = "KillAura"
})

local PlayerTab = FlingWindow:CreateTab({
    Name = "Player"
})

local VisualTab = FlingWindow:CreateTab({
    Name = "Visual"
})

-- ============================================
-- FLING TAB
-- ============================================
local FlingSection = FlingTab:CreateSection({
    Name = "Fling Options"
})

-- Add Toggles
FlingSection:AddToggle({
    Name = "Instant Fling",
    Flag = "InstantFling",
    Callback = function(value)
        instantFlingEnabled = value
        if value then
            print("âœ“ Instant Fling ENABLED")
        else
            print("âœ— Instant Fling DISABLED")
        end
    end
})

FlingSection:AddToggle({
    Name = "Fling Aura",
    Flag = "FlingAura",
    Callback = function(value)
        auraEnabled = value
        if value then
            print("âœ“ Fling Aura ENABLED")
            createAura()
        else
            print("âœ— Fling Aura DISABLED")
            destroyAura()
        end
    end
})

-- Settings Section
local FlingSettingsSection = FlingTab:CreateSection({
    Name = "Settings",
    Side = "Right"
})

FlingSettingsSection:AddSlider({
    Name = "Aura Radius",
    Flag = "AuraRadius",
    Value = 15,
    Min = 5,
    Max = 50,
    Format = function(Value)
        return "Radius: " .. tostring(Value)
    end,
    Callback = function(value)
        AURA_RADIUS = value
        print("Fling Aura Radius set to:", value)
        
        -- Update aura visual immediately if it exists
        if auraRingParts and #auraRingParts > 0 then
            updateAuraRing()
            print("âœ“ Fling aura ring updated!")
        end
    end
})

FlingSettingsSection:AddSlider({
    Name = "Fling Power",
    Flag = "FlingPower",
    Value = 500,
    Min = 100,
    Max = 100000,
    Format = function(Value)
        return "Power: " .. tostring(Value)
    end,
    Callback = function(value)
        FLING_POWER = value
        print("Fling Power set to:", value, "- will apply to next fling")
    end
})

-- Aura Visualization Section
local AuraVisualSection = FlingTab:CreateSection({
    Name = "Aura Visualization",
    Side = "Right"
})

AuraVisualSection:AddToggle({
    Name = "Show Aura Ring",
    Flag = "ShowAuraVisualization",
    Value = true,
    Callback = function(value)
        showAuraVisualization = value
        
        if value then
            -- Recreate the ring if aura is enabled
            if auraEnabled then
                createAuraRing()
            end
            print("âœ“ Fling aura visualization ENABLED")
        else
            -- Hide the ring
            for _, part in pairs(auraRingParts) do
                if part then
                    part:Destroy()
                end
            end
            auraRingParts = {}
            print("âœ— Fling aura visualization DISABLED")
        end
    end
})

AuraVisualSection:AddColorpicker({
    Name = "Ring Color",
    Flag = "AuraRingColor",
    Value = Color3.fromRGB(255, 0, 127),
    Callback = function(value)
        auraRingColor = value
        print("Fling ring color changed to:", value)
        
        -- Update ring color immediately
        if auraRingParts and #auraRingParts > 0 then
            for _, part in pairs(auraRingParts) do
                if part then
                    part.Color = value
                end
            end
            print("âœ“ Fling ring color updated!")
        end
    end
})

AuraVisualSection:AddSlider({
    Name = "Ring Thickness",
    Flag = "RingThickness",
    Value = 0.5,
    Min = 0.1,
    Max = 2,
    Format = function(Value)
        return "Thickness: " .. tostring(Value)
    end,
    Callback = function(value)
        auraRingThickness = value
        print("Fling ring thickness set to:", value)
        
        -- Update ring immediately
        if auraRingParts and #auraRingParts > 0 then
            updateAuraRing()
            print("âœ“ Fling ring thickness updated!")
        end
    end
})

AuraVisualSection:AddSlider({
    Name = "Ring Height",
    Flag = "RingHeight",
    Value = 0.3,
    Min = 0.1,
    Max = 2,
    Format = function(Value)
        return "Height: " .. tostring(Value)
    end,
    Callback = function(value)
        auraRingHeight = value
        print("Fling ring height set to:", value)
        
        -- Update ring immediately
        if auraRingParts and #auraRingParts > 0 then
            updateAuraRing()
            print("âœ“ Fling ring height updated!")
        end
    end
})

-- Ring Animation Section
local RingAnimationSection = FlingTab:CreateSection({
    Name = "Ring Animation",
    Side = "Right"
})

RingAnimationSection:AddToggle({
    Name = "Spin Ring",
    Flag = "SpinRing",
    Value = false,
    Callback = function(value)
        auraRingSpin = value
        if value then
            print("âœ“ Fling ring spinning ENABLED")
        else
            print("âœ— Fling ring spinning DISABLED")
            currentRotation = 0 -- Reset rotation
        end
    end
})

RingAnimationSection:AddSlider({
    Name = "Spin Speed",
    Flag = "SpinSpeed",
    Value = 1,
    Min = 0.1,
    Max = 5,
    Format = function(Value)
        return "Speed: " .. tostring(Value) .. "x"
    end,
    Callback = function(value)
        auraSpinSpeed = value
        print("Fling spin speed set to:", value .. "x")
    end
})

RingAnimationSection:AddDropdown({
    Name = "Ring Style",
    Flag = "RingStyle",
    List = {"Dots", "Solid"},
    Default = "Dots",
    Callback = function(value)
        local newStyle = value:lower()
        if newStyle ~= auraRingStyle then
            auraRingStyle = newStyle
            print("Fling ring style changed to:", value)
            
            -- Recreate ring with new style if it exists
            if auraRingParts and #auraRingParts > 0 and showAuraVisualization then
                createAuraRing()
                print("âœ“ Fling ring recreated with new style!")
            end
        end
    end
})

-- ============================================
-- TARGET SYSTEM (SIMPLIFIED - AUTO-TARGET ONLY)
-- ============================================
local TargetSection = FlingTab:CreateSection({
    Name = "Target Player"
})

TargetSection:AddToggle({
    Name = "Enable Auto Target",
    Flag = "AutoTarget",
    Callback = function(value)
        targetEnabled = value
        autoTargetEnabled = value
        if value then
            print("ðŸŽ¯ Auto Target ENABLED - Will follow closest player")
            targetPlayer = nil -- Clear any previous selection
        else
            print("âœ— Auto Target DISABLED")
            targetPlayer = nil
            -- Stop any active tween
            if targetTween then
                targetTween:Cancel()
                targetTween = nil
            end
            -- Clean up BodyPosition
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local bodyPos = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("TargetBodyPosition")
                if bodyPos then
                    bodyPos:Destroy()
                end
            end
        end
    end
})

-- Target Settings
local TargetSettingsSection = FlingTab:CreateSection({
    Name = "Target Settings",
    Side = "Right"
})

TargetSettingsSection:AddSlider({
    Name = "Max Follow Distance",
    Flag = "TargetMaxDistance",
    Value = 1500,
    Min = 100,
    Max = 3000,
    Format = function(Value)
        return "Max: " .. tostring(Value) .. " studs"
    end,
    Callback = function(value)
        TARGET_MAX_DISTANCE = value
        print("Target max distance set to:", value)
    end
})

TargetSettingsSection:AddSlider({
    Name = "Stop Distance",
    Flag = "TargetStopDistance",
    Value = 1,
    Min = 1,
    Max = 100,
    Format = function(Value)
        return "Stop: " .. tostring(Value) .. " studs"
    end,
    Callback = function(value)
        TARGET_STOP_DISTANCE = value
        print("Target stop distance set to:", value)
    end
})

TargetSettingsSection:AddSlider({
    Name = "Tween Speed",
    Flag = "TargetTweenSpeed",
    Value = 50,
    Min = 10,
    Max = 200,
    Format = function(Value)
        return "Speed: " .. tostring(Value) .. " studs/s"
    end,
    Callback = function(value)
        TARGET_TWEEN_SPEED = value
        print("Target tween speed set to:", value, "studs/s")
    end
})

TargetSettingsSection:AddToggle({
    Name = "Map Bounds Protection",
    Flag = "MapBoundsEnabled",
    Value = true,
    Callback = function(value)
        MAP_BOUNDS_ENABLED = value
        if value then
            print("âœ“ Map Bounds Protection ENABLED")
            print("  Center:", MAP_BOUNDS_CENTER)
            print("  Size:", MAP_BOUNDS_SIZE)
        else
            print("âœ— Map Bounds Protection DISABLED")
        end
    end
})

TargetSettingsSection:AddButton({
    Name = "Return to Spawn Now",
    Callback = function()
        print("ðŸ  Manually returning to spawn...")
        returnToSpawn()
    end
})

-- ============================================
-- KILLAURA TAB (COMPLETELY SEPARATE)
-- ============================================
local KillAuraSection = KillAuraTab:CreateSection({
    Name = "KillAura Options"
})

KillAuraSection:AddToggle({
    Name = "Enable KillAura",
    Flag = "KillAura",
    Callback = function(value)
        killAuraEnabled = value
        if value then
            print("â˜ ï¸ KillAura ENABLED")
            createKillAura()
        else
            print("âœ— KillAura DISABLED")
            destroyKillAura()
        end
    end
})

KillAuraSection:AddButton({
    Name = "Scan for Kill Zones",
    Callback = function()
        print("=== SCANNING FOR KILL ZONES ===")
        local killZones = {}
        
        for _, obj in pairs(workspace:GetDescendants()) do
            -- Check part names
            if obj:IsA("BasePart") then
                local name = obj.Name:lower()
                if name:match("kill") or name:match("death") or 
                   name:match("void") or name:match("lava") or
                   name:match("damage") or name:match("hazard") or
                   name:match("hurt") or name:match("deadly") then
                    table.insert(killZones, {
                        Part = obj,
                        Name = obj.Name,
                        Position = obj.Position,
                        Size = obj.Size
                    })
                    print("âœ“ Kill Zone:", obj:GetFullName())
                    print("  Position:", obj.Position)
                    print("  Size:", obj.Size)
                end
            end
            
            -- Check for scripts that might kill
            if (obj:IsA("Script") or obj:IsA("LocalScript")) and obj.Parent:IsA("BasePart") then
                local name = obj.Name:lower()
                if name:match("kill") or name:match("damage") or name:match("touch") or name:match("death") then
                    print("âœ“ Kill Script:", obj:GetFullName())
                    print("  On part:", obj.Parent.Name)
                    print("  Position:", obj.Parent.Position)
                end
            end
        end
        
        if #killZones > 0 then
            print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
            print("Total kill zones found:", #killZones)
            print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        else
            print("âš ï¸ No kill zones found in workspace")
        end
    end
})

-- KillAura Settings Section
local KillAuraSettingsSection = KillAuraTab:CreateSection({
    Name = "Settings",
    Side = "Right"
})

KillAuraSettingsSection:AddSlider({
    Name = "KillAura Radius",
    Flag = "KillAuraRadius",
    Value = 15,
    Min = 5,
    Max = 50,
    Format = function(v)
        return "Radius: " .. v
    end,
    Callback = function(v)
        KILLAURA_RADIUS = v
        print("KillAura Radius set to:", v)
        
        -- Update visual if it exists
        if killAuraRingParts and #killAuraRingParts > 0 then
            updateKillAuraRing()
            print("âœ“ KillAura ring updated!")
        end
    end
})

KillAuraSettingsSection:AddSlider({
    Name = "Void Y Position",
    Flag = "KillAuraVoidY",
    Value = -10000,
    Min = -50000,
    Max = -100,
    Format = function(v)
        return "Void Y: " .. v
    end,
    Callback = function(v)
        KILLAURA_VOID_Y = v
        print("KillAura Void Y set to:", v)
    end
})

KillAuraSettingsSection:AddSlider({
    Name = "Base Slam Velocity",
    Flag = "KillAuraBaseVelocity",
    Value = 50000,
    Min = 1000,
    Max = 200000,
    Format = function(v)
        return "Base: " .. v
    end,
    Callback = function(v)
        KILLAURA_BASE_VELOCITY = v
        print("KillAura Base Velocity set to:", v)
    end
})

KillAuraSettingsSection:AddSlider({
    Name = "Spike Velocity (Nuclear)",
    Flag = "KillAuraSpikeVelocity",
    Value = 100000,
    Min = 10000,
    Max = 500000,
    Format = function(v)
        return "Spike: " .. v
    end,
    Callback = function(v)
        KILLAURA_SPIKE_VELOCITY = v
        print("KillAura Spike Velocity set to:", v)
    end
})

KillAuraSettingsSection:AddSlider({
    Name = "Kill Delay",
    Flag = "KillAuraDelay",
    Value = 1.5,
    Min = 0.5,
    Max = 5,
    Format = function(v)
        return "Delay: " .. v .. "s"
    end,
    Callback = function(v)
        KILLAURA_DELAY = v
        print("KillAura Delay set to:", v .. "s")
    end
})

-- KillAura Visualization Section
local KillAuraVisualSection = KillAuraTab:CreateSection({
    Name = "Visualization",
    Side = "Right"
})

KillAuraVisualSection:AddToggle({
    Name = "Show KillAura Ring",
    Flag = "ShowKillAuraVisualization",
    Value = true,
    Callback = function(value)
        showKillAuraVisualization = value
        
        if value then
            if killAuraEnabled then
                createKillAuraRing()
            end
            print("âœ“ KillAura visualization ENABLED")
        else
            for _, part in pairs(killAuraRingParts) do
                if part then
                    part:Destroy()
                end
            end
            killAuraRingParts = {}
            print("âœ— KillAura visualization DISABLED")
        end
    end
})

KillAuraVisualSection:AddColorpicker({
    Name = "Ring Color",
    Flag = "KillAuraRingColor",
    Value = Color3.fromRGB(255, 0, 0),
    Callback = function(value)
        killAuraRingColor = value
        print("KillAura ring color changed to:", value)
        
        if killAuraRingParts and #killAuraRingParts > 0 then
            for _, part in pairs(killAuraRingParts) do
                if part then
                    part.Color = value
                end
            end
            print("âœ“ KillAura ring color updated!")
        end
    end
})

KillAuraVisualSection:AddSlider({
    Name = "Ring Thickness",
    Flag = "KillAuraRingThickness",
    Value = 0.5,
    Min = 0.1,
    Max = 2,
    Format = function(Value)
        return "Thickness: " .. tostring(Value)
    end,
    Callback = function(value)
        killAuraRingThickness = value
        print("KillAura ring thickness set to:", value)
        
        if killAuraRingParts and #killAuraRingParts > 0 then
            updateKillAuraRing()
            print("âœ“ KillAura ring thickness updated!")
        end
    end
})

KillAuraVisualSection:AddSlider({
    Name = "Ring Height",
    Flag = "KillAuraRingHeight",
    Value = 0.3,
    Min = 0.1,
    Max = 2,
    Format = function(Value)
        return "Height: " .. tostring(Value)
    end,
    Callback = function(value)
        killAuraRingHeight = value
        print("KillAura ring height set to:", value)
        
        if killAuraRingParts and #killAuraRingParts > 0 then
            updateKillAuraRing()
            print("âœ“ KillAura ring height updated!")
        end
    end
})

-- KillAura Ring Animation Section
local KillAuraAnimationSection = KillAuraTab:CreateSection({
    Name = "Ring Animation",
    Side = "Right"
})

KillAuraAnimationSection:AddToggle({
    Name = "Spin Ring",
    Flag = "KillAuraSpinRing",
    Value = false,
    Callback = function(value)
        killAuraRingSpin = value
        if value then
            print("âœ“ KillAura ring spinning ENABLED")
        else
            print("âœ— KillAura ring spinning DISABLED")
            killAuraCurrentRotation = 0
        end
    end
})

KillAuraAnimationSection:AddSlider({
    Name = "Spin Speed",
    Flag = "KillAuraSpinSpeed",
    Value = 1,
    Min = 0.1,
    Max = 5,
    Format = function(Value)
        return "Speed: " .. tostring(Value) .. "x"
    end,
    Callback = function(value)
        killAuraSpinSpeed = value
        print("KillAura spin speed set to:", value .. "x")
    end
})

KillAuraAnimationSection:AddDropdown({
    Name = "Ring Style",
    Flag = "KillAuraRingStyle",
    List = {"Dots", "Solid"},
    Default = "Dots",
    Callback = function(value)
        local newStyle = value:lower()
        if newStyle ~= killAuraRingStyle then
            killAuraRingStyle = newStyle
            print("KillAura ring style changed to:", value)
            
            if killAuraRingParts and #killAuraRingParts > 0 and showKillAuraVisualization then
                createKillAuraRing()
                print("âœ“ KillAura ring recreated with new style!")
            end
        end
    end
})

-- ============================================
-- PLAYER TAB
-- ============================================
local PlayerMovementSection = PlayerTab:CreateSection({
    Name = "Movement"
})

PlayerMovementSection:AddToggle({
    Name = "Force Shift Lock",
    Flag = "ForceShiftLock",
    Callback = function(value)
        forceShiftLockEnabled = value
        pcall(function()
            if value then
                LocalPlayer.DevEnableMouseLock = true
                print("âœ“ Shift Lock ENABLED")
            else
                LocalPlayer.DevEnableMouseLock = false
                print("âœ— Shift Lock DISABLED")
            end
        end)
    end
})

PlayerMovementSection:AddToggle({
    Name = "Custom Walkspeed",
    Flag = "CustomWalkspeed",
    Callback = function(value)
        customWalkspeedEnabled = value
        if value then
            print("âœ“ Custom Walkspeed ENABLED")
            print("DEBUG: Setting walkspeed to:", walkspeedValue)
            -- Apply immediately
            if LocalPlayer.Character then
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    print("DEBUG: Current WalkSpeed:", humanoid.WalkSpeed)
                    humanoid.WalkSpeed = walkspeedValue
                    print("DEBUG: After setting WalkSpeed:", humanoid.WalkSpeed)
                end
            end
        else
            print("âœ— Custom Walkspeed DISABLED")
            -- Reset to default
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = 16
            end
        end
    end
})

PlayerMovementSection:AddToggle({
    Name = "Air Control",
    Flag = "AirControl",
    Callback = function(value)
        airControlEnabled = value
        if value then
            print("âœ“ Air Control ENABLED")
        else
            print("âœ— Air Control DISABLED")
        end
    end
})

PlayerMovementSection:AddToggle({
    Name = "Noclip",
    Flag = "Noclip",
    Callback = function(value)
        noclipEnabled = value
        if value then
            print("âœ“ Noclip ENABLED")
            
            -- Create noclip loop
            noclipConnection = RunService.Stepped:Connect(function()
                if noclipEnabled and LocalPlayer.Character then
                    for _, child in pairs(LocalPlayer.Character:GetDescendants()) do
                        if child:IsA("BasePart") and child.CanCollide == true then
                            child.CanCollide = false
                        end
                    end
                end
            end)
        else
            print("âœ— Noclip DISABLED")
            
            -- Disconnect noclip loop
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
            
            -- Re-enable collision
            if LocalPlayer.Character then
                for _, child in pairs(LocalPlayer.Character:GetDescendants()) do
                    if child:IsA("BasePart") then
                        if child.Name ~= "Head" then
                            child.CanCollide = true
                        end
                    end
                end
            end
        end
    end
})

PlayerMovementSection:AddToggle({
    Name = "Bhop",
    Flag = "Bhop",
    Callback = function(value)
        bhopEnabled = value
        if value then
            print("âœ“ Bhop ENABLED")
        else
            print("âœ— Bhop DISABLED")
        end
    end
})

PlayerMovementSection:AddToggle({
    Name = "Infinite Jump",
    Flag = "InfiniteJump",
    Callback = function(value)
        infiniteJumpEnabled = value
        if value then
            print("âœ“ Infinite Jump ENABLED")
        else
            print("âœ— Infinite Jump DISABLED")
        end
    end
})

PlayerMovementSection:AddToggle({
    Name = "Auto Strafe",
    Flag = "AutoStrafe",
    Callback = function(value)
        autoStrafeEnabled = value
        if value then
            print("âœ“ Auto Strafe ENABLED")
        else
            print("âœ— Auto Strafe DISABLED")
        end
    end
})

-- Auto Trash Talk Section
local AutoSpamTrashSection = PlayerTab:CreateSection({
    Name = "Auto Trash Talk"
})

AutoSpamTrashSection:AddToggle({
    Name = "Enable Auto Spam",
    Flag = "AutoSpamTrashTalk",
    Callback = function(value)
        autoSpamTrashTalk = value
        if value then
            print("ðŸ’¬ Auto Spam Trash Talk ENABLED")
            lastAutoSpam = tick() -- Start immediately
        else
            print("âœ— Auto Spam Trash Talk DISABLED")
        end
    end
})

AutoSpamTrashSection:AddSlider({
    Name = "Frequency",
    Flag = "AutoSpamFrequency",
    Value = 5,
    Min = 2,
    Max = 30,
    Format = function(Value)
        return "Every " .. tostring(Value) .. "s"
    end,
    Callback = function(value)
        autoSpamFrequency = value
        print("Auto spam frequency set to:", value, "seconds")
    end
})

AutoSpamTrashSection:AddButton({
    Name = "Send Message Now",
    Callback = function()
        print("ðŸ’¬ Sending spam message now...")
        sendTrashTalk("spam", true)
    end
})

AutoSpamTrashSection:AddButton({
    Name = "Scan Chat Remotes",
    Callback = function()
        print("=== SCANNING FOR CHAT REMOTES ===")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        
        print("Checking ReplicatedStorage...")
        for _, child in pairs(ReplicatedStorage:GetDescendants()) do
            if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
                local name = child.Name:lower()
                if name:match("chat") or name:match("message") or name:match("say") or name:match("talk") then
                    print("âœ“ Found:", child:GetFullName(), "Type:", child.ClassName)
                end
            end
        end
        
        print("Checking TextChatService...")
        local TextChatService = game:GetService("TextChatService")
        print("  ChatVersion:", TextChatService.ChatVersion)
        if TextChatService:FindFirstChild("TextChannels") then
            for _, channel in pairs(TextChatService.TextChannels:GetChildren()) do
                print("  âœ“ Channel:", channel.Name)
            end
        end
        
        print("=== SCAN COMPLETE ===")
    end
})

-- Movement Settings
local PlayerSettingsSection = PlayerTab:CreateSection({
    Name = "Settings",
    Side = "Right"
})

PlayerSettingsSection:AddSlider({
    Name = "Walkspeed Value",
    Flag = "Walkspeed",
    Value = 16,
    Min = 16,
    Max = 200,
    Format = function(Value)
        return "Walkspeed: " .. tostring(Value)
    end,
    Callback = function(value)
        walkspeedValue = value
        print("Walkspeed set to:", value)
        
        -- Apply immediately if custom walkspeed is enabled
        if customWalkspeedEnabled and LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = value
            end
        end
    end
})

PlayerSettingsSection:AddDropdown({
    Name = "Bhop Type",
    Flag = "BhopType",
    List = {"Advanced", "Simple", "LowHop"},
    Default = "Advanced",
    Callback = function(value)
        bhopType = value:lower()
        print("Bhop type set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "Advanced: Jump Speed Boost",
    Flag = "JumpSpeedBoost",
    Value = 2.0,
    Min = 0.5,
    Max = 10,
    Format = function(Value)
        return "Jump Boost: " .. tostring(Value) .. "x"
    end,
    Callback = function(value)
        bhopJumpBoost = value
        print("Jump speed boost set to:", value .. "x")
    end
})

PlayerSettingsSection:AddSlider({
    Name = "LowHop: Jump Height",
    Flag = "LowHopJumpHeight",
    Value = 3,
    Min = 1,
    Max = 10,
    Format = function(Value)
        return "LowHop Height: " .. tostring(Value)
    end,
    Callback = function(value)
        lowHopJumpHeight = value
        print("LowHop jump height set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "LowHop: Fall Speed",
    Flag = "LowHopFallSpeed",
    Value = 50,
    Min = 0,
    Max = 500,
    Format = function(Value)
        return "LowHop Fall: " .. tostring(Value)
    end,
    Callback = function(value)
        bhopFallSpeed = value
        print("LowHop fall speed set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "Auto Strafe: Circle Radius",
    Flag = "AutoStrafeRadius",
    Value = 5,
    Min = 1,
    Max = 20,
    Format = function(Value)
        return "Strafe Radius: " .. tostring(Value)
    end,
    Callback = function(value)
        autoStrafeRadius = value
        print("Auto strafe radius set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "Auto Strafe: Rotation Speed",
    Flag = "AutoStrafeSpeed",
    Value = 1,
    Min = 0.1,
    Max = 10,
    Format = function(Value)
        return "Strafe Speed: " .. tostring(Value)
    end,
    Callback = function(value)
        autoStrafeIntensity = value
        print("Auto strafe speed set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "Infinite Jump: Power",
    Flag = "InfiniteJumpPower",
    Value = 50,
    Min = 10,
    Max = 200,
    Format = function(Value)
        return "Jump Power: " .. tostring(Value)
    end,
    Callback = function(value)
        infiniteJumpPower = value
        print("Infinite jump power set to:", value)
    end
})

-- Walkspeed system
local walkspeedConnection = nil

local function setupWalkspeed(character)
    if walkspeedConnection then
        walkspeedConnection:Disconnect()
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    
    -- Listen for any changes to WalkSpeed and override them
    walkspeedConnection = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if customWalkspeedEnabled then
            -- The game just changed walkspeed, override it back
            if humanoid.WalkSpeed ~= walkspeedValue then
                humanoid.WalkSpeed = walkspeedValue
                print("DEBUG: Overriding game walkspeed, forcing to:", walkspeedValue)
            end
        end
    end)
    
    -- Also apply immediately
    if customWalkspeedEnabled then
        humanoid.WalkSpeed = walkspeedValue
    end
end

-- Setup for current character
if LocalPlayer.Character then
    setupWalkspeed(LocalPlayer.Character)
end

-- Setup for future characters
LocalPlayer.CharacterAdded:Connect(setupWalkspeed)

-- Bhop jump handler
LocalPlayer.CharacterAdded:Connect(function(character)
    local humanoid = character:WaitForChild("Humanoid")
    
    humanoid.Jumping:Connect(function()
        if bhopEnabled then
            if bhopType == "advanced" then
                -- Advanced bhop: speed boost on jump using slider value
                currSpeed = math.min(currSpeed + bhopJumpBoost, speedCap)
                humanoid.WalkSpeed = currSpeed
                print("Jump boost! Speed:", currSpeed)
            elseif bhopType == "lowhop" then
                -- LowHop: speed boost on jump using slider value
                currSpeed = math.min(currSpeed + 1.5, speedCap)
                humanoid.WalkSpeed = currSpeed
                
                -- Use slider value for jump height
                humanoid.JumpPower = lowHopJumpHeight * 7 -- Convert to JumpPower
                humanoid.JumpHeight = lowHopJumpHeight
                print("LowHop! Speed:", currSpeed)
            end
        end
    end)
end)

-- Apply to current character if exists
if LocalPlayer.Character then
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.Jumping:Connect(function()
            if bhopEnabled then
                if bhopType == "advanced" then
                    currSpeed = math.min(currSpeed + bhopJumpBoost, speedCap)
                    humanoid.WalkSpeed = currSpeed
                    print("Jump boost! Speed:", currSpeed)
                elseif bhopType == "lowhop" then
                    currSpeed = math.min(currSpeed + 1.5, speedCap)
                    humanoid.WalkSpeed = currSpeed
                    humanoid.JumpPower = lowHopJumpHeight * 7
                    humanoid.JumpHeight = lowHopJumpHeight
                    print("LowHop! Speed:", currSpeed)
                end
            end
        end)
    end
end

-- Infinite Jump system
local UserInputService = game:GetService("UserInputService")

UserInputService.JumpRequest:Connect(function()
    if infiniteJumpEnabled and LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            -- Apply custom jump power
            local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                rootPart.Velocity = Vector3.new(
                    rootPart.Velocity.X,
                    infiniteJumpPower,
                    rootPart.Velocity.Z
                )
            end
        end
    end
end)

-- ============================================
-- TRASH TALK HELPER FUNCTION
-- ============================================

local function sendTrashTalk(messageType, ignoreDelay)
    -- Safety check: messageType must be valid
    if not messageType or type(messageType) ~= "string" then
        warn("sendTrashTalk called with invalid messageType:", messageType)
        return
    end
    
    if not trashTalkEnabled and messageType ~= "spam" then return end
    if messageType == "spam" and not autoSpamTrashTalk then return end
    
    -- Check delay (unless ignoreDelay is true, used for auto spam)
    if not ignoreDelay then
        if tick() - lastTrashTalk < trashTalkDelay then
            return -- Too soon
        end
    end
    
    -- Get random message from the appropriate list
    local messageList = trashTalkMessages[messageType]
    if not messageList or #messageList == 0 then 
        warn("No messages found for type:", messageType)
        return 
    end
    
    local randomMessage = messageList[math.random(1, #messageList)]
    
    -- Try multiple chat systems
    local success = false
    local err = nil
    
    -- Method 1: Try TextChatService (new chat system)
    success, err = pcall(function()
        local TextChatService = game:GetService("TextChatService")
        local textChannel = TextChatService:FindFirstChild("TextChannels")
        if textChannel then
            textChannel = textChannel:FindFirstChild("RBXGeneral")
            if textChannel and textChannel.SendAsync then
                textChannel:SendAsync(randomMessage)
                return true
            end
        end
        error("TextChatService not available")
    end)
    
    if success then
        if messageType == "spam" then
            print("ðŸ’¬ [AUTO] Trash talk sent:", randomMessage)
        else
            print("ðŸ’¬ Trash talk sent:", randomMessage)
        end
        lastTrashTalk = tick()
        return
    end
    
    -- Method 2: Try DefaultChatSystemChatEvents (legacy chat)
    success, err = pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local DefaultChat = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
        
        if not DefaultChat then
            error("DefaultChatSystemChatEvents not found")
        end
        
        local SayMessage = DefaultChat:FindFirstChild("SayMessageRequest")
        if not SayMessage then
            error("SayMessageRequest not found")
        end
        
        SayMessage:FireServer(randomMessage, "All")
    end)
    
    if success then
        if messageType == "spam" then
            print("ðŸ’¬ [AUTO] Trash talk sent:", randomMessage)
        else
            print("ðŸ’¬ Trash talk sent:", randomMessage)
        end
        lastTrashTalk = tick()
        return
    end
    
    -- Method 3: Try game-specific chat (some games have custom chat)
    success, err = pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        
        -- Try common custom chat remotes
        local chatRemotes = {
            "ChatRemote",
            "ChatEvent",
            "SendMessage",
            "Chat",
            "MessageRemote"
        }
        
        for _, remoteName in pairs(chatRemotes) do
            local remote = ReplicatedStorage:FindFirstChild(remoteName)
            if remote then
                if remote:IsA("RemoteEvent") then
                    remote:FireServer(randomMessage)
                    return true
                elseif remote:IsA("RemoteFunction") then
                    remote:InvokeServer(randomMessage)
                    return true
                end
            end
        end
        
        error("No custom chat remote found")
    end)
    
    if success then
        if messageType == "spam" then
            print("ðŸ’¬ [AUTO] Trash talk sent:", randomMessage)
        else
            print("ðŸ’¬ Trash talk sent:", randomMessage)
        end
        lastTrashTalk = tick()
        return
    end
    
    -- All methods failed
    warn("âš ï¸ All chat methods failed. This game may use a custom chat system.")
    warn("   Try looking in ReplicatedStorage for chat-related remotes.")
end

-- ============================================
-- MAP BOUNDS HELPER FUNCTIONS
-- ============================================

-- Helper function to check if position is within map bounds
local function isWithinMapBounds(position)
    if not MAP_BOUNDS_ENABLED then
        return true -- Bounds disabled, always return true
    end
    
    local min = MAP_BOUNDS_CENTER - (MAP_BOUNDS_SIZE / 2)
    local max = MAP_BOUNDS_CENTER + (MAP_BOUNDS_SIZE / 2)
    
    return position.X >= min.X and position.X <= max.X and
           position.Y >= min.Y and position.Y <= max.Y and
           position.Z >= min.Z and position.Z <= max.Z
end

-- Helper function to return player to spawn (0,0,0 or map center)
local function returnToSpawn()
    if returningToSpawn then return end -- Already returning
    
    returningToSpawn = true
    print("âš ï¸ OUT OF BOUNDS! Returning to spawn...")
    
    local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not rootPart then 
        returningToSpawn = false
        return 
    end
    
    -- Clean up any existing targeting
    targetPlayer = nil
    local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
    if bodyPos then
        bodyPos:Destroy()
    end
    
    -- Create BodyPosition to return to spawn
    local returnBodyPos = Instance.new("BodyPosition")
    returnBodyPos.Name = "ReturnToSpawnBodyPosition"
    returnBodyPos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    returnBodyPos.P = 10000
    returnBodyPos.D = 500
    returnBodyPos.Position = Vector3.new(0, 50, 0) -- Return to Y=50 to avoid spawning in ground
    returnBodyPos.Parent = rootPart
    
    -- Wait until we're close to spawn
    task.spawn(function()
        while rootPart and rootPart.Parent do
            local distance = (rootPart.Position - Vector3.new(0, 50, 0)).Magnitude
            
            if distance < 10 then
                -- We're at spawn, clean up
                print("âœ“ Returned to spawn successfully")
                if returnBodyPos and returnBodyPos.Parent then
                    returnBodyPos:Destroy()
                end
                returningToSpawn = false
                break
            end
            
            task.wait(0.5)
        end
        
        -- Failsafe cleanup
        if returnBodyPos and returnBodyPos.Parent then
            returnBodyPos:Destroy()
        end
        returningToSpawn = false
    end)
end

-- ============================================
-- MAIN HEARTBEAT LOOP
-- ============================================

-- Backup loop in case the event doesn't catch everything
RunService.Heartbeat:Connect(function(dt)
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        -- ============================================
        -- MAP BOUNDS CHECK (HIGHEST PRIORITY)
        -- ============================================
        if rootPart and MAP_BOUNDS_ENABLED and not returningToSpawn then
            local myPosition = rootPart.Position
            
            -- Check if WE are out of bounds
            if not isWithinMapBounds(myPosition) then
                -- We're out of bounds! Return to spawn immediately
                returnToSpawn()
                return -- Skip all other processing
            end
        end
        
        -- If we're returning to spawn, skip all targeting/aura logic
        if returningToSpawn then
            return
        end
        
        -- TARGET SYSTEM
        if targetEnabled and rootPart then
            -- AUTO TARGET MODE: Find closest player
            if autoTargetEnabled then
                local closestPlayer = nil
                local closestDistance = math.huge
                
                -- Get PlayersInPlots folder reference
                local playersInPlotsFolder = workspace:FindFirstChild("PlotItems")
                if playersInPlotsFolder then
                    playersInPlotsFolder = playersInPlotsFolder:FindFirstChild("PlayersInPlots")
                end
                
                -- Find the closest player within range
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local playerRoot = player.Character.HumanoidRootPart
                        local distance = (playerRoot.Position - rootPart.Position).Magnitude
                        
                        -- CRITICAL: Check if player is within map bounds
                        if MAP_BOUNDS_ENABLED and not isWithinMapBounds(playerRoot.Position) then
                            -- Player is out of bounds (probably flung), skip them
                            continue
                        end
                        
                        -- CRITICAL: Skip players that are unreasonably far (probably flung)
                        if distance > 10000 then
                            -- Skip this player - they're too far away (probably flung)
                            continue
                        end
                        
                        -- Check if player is in a safe zone (PlayersInPlots folder)
                        local inSafeZone = false
                        if playersInPlotsFolder and player.Character.Parent == playersInPlotsFolder then
                            inSafeZone = true
                        end
                        
                        -- Check if within max distance, closer than current closest, and NOT in safe zone
                        if distance <= TARGET_MAX_DISTANCE and distance < closestDistance and not inSafeZone then
                            closestPlayer = player
                            closestDistance = distance
                        end
                    end
                end
                
                -- Update target to closest player
                if closestPlayer and closestPlayer ~= targetPlayer then
                    targetPlayer = closestPlayer
                    print("ðŸŽ¯ Auto-targeting:", targetPlayer.Name, "| Distance:", math.floor(closestDistance), "studs")
                elseif not closestPlayer then
                    targetPlayer = nil
                    if targetTween then
                        targetTween:Cancel()
                        targetTween = nil
                    end
                end
            end
            
            -- MANUAL OR AUTO TARGET: Follow the selected player
            if targetPlayer then
                -- Check if target player still exists in game
                if not targetPlayer.Parent then
                    print("âš ï¸ Target player left the game")
                    targetPlayer = nil
                    
                    -- Clean up BodyPosition
                    if rootPart then
                        local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
                        if bodyPos then
                            bodyPos:Destroy()
                        end
                    end
                    
                    if targetTween then
                        targetTween:Cancel()
                        targetTween = nil
                    end
                elseif targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local targetRoot = targetPlayer.Character.HumanoidRootPart
                    local distance = (targetRoot.Position - rootPart.Position).Magnitude
                
                    -- PRIORITY CHECK: Is target outside map bounds?
                    if MAP_BOUNDS_ENABLED and not isWithinMapBounds(targetRoot.Position) then
                        print("âš ï¸ Target is outside map bounds (flung) - stopping follow")
                        
                        -- Clean up BodyPosition
                        local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
                        if bodyPos then
                            bodyPos:Destroy()
                        end
                        
                        if targetTween then
                            targetTween:Cancel()
                            targetTween = nil
                        end
                        
                        -- In auto mode, find new target
                        if autoTargetEnabled then
                            targetPlayer = nil
                        end
                    else
                        -- Target is within bounds, continue with normal checks
                        
                        -- Check if target is in a safe zone (Plot) - CHECK EVERY FRAME
                        -- Simply check if their character is in the PlayersInPlots folder
                        local targetInSafeZone = false
                    local playersInPlotsFolder = workspace:FindFirstChild("PlotItems")
                    if playersInPlotsFolder then
                        playersInPlotsFolder = playersInPlotsFolder:FindFirstChild("PlayersInPlots")
                    end
                    
                    if playersInPlotsFolder and targetPlayer.Character then
                        -- Check if their character is in the PlayersInPlots folder
                        if targetPlayer.Character.Parent == playersInPlotsFolder then
                            targetInSafeZone = true
                            -- Only print once per entry
                            if not recentlyKilled[targetPlayer] or tick() - recentlyKilled[targetPlayer] > 2 then
                                print("âš ï¸ Target", targetPlayer.Name, "is in safe zone (PlayersInPlots)")
                                recentlyKilled[targetPlayer] = tick()
                            end
                        end
                    end
                    
                    -- If target is in safe zone, IMMEDIATELY stop and clean up
                    if targetInSafeZone then
                        -- Clean up BodyPosition IMMEDIATELY
                        local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
                        if bodyPos then
                            bodyPos:Destroy()
                        end
                        
                        if targetTween then
                            targetTween:Cancel()
                            targetTween = nil
                        end
                        
                        -- In auto mode, find new target. In manual mode, keep the target but don't follow
                        if autoTargetEnabled then
                            targetPlayer = nil
                        end
                        
                        -- CRITICAL: Don't continue processing this frame
                    elseif distance <= TARGET_MAX_DISTANCE then
                        -- Check if WE are in a safe zone - if so, don't tween
                        local weAreInSafeZone = false
                        local playersInPlotsFolder = workspace:FindFirstChild("PlotItems")
                        if playersInPlotsFolder then
                            playersInPlotsFolder = playersInPlotsFolder:FindFirstChild("PlayersInPlots")
                        end
                        
                        if playersInPlotsFolder and LocalPlayer.Character and LocalPlayer.Character.Parent == playersInPlotsFolder then
                            weAreInSafeZone = true
                        end
                        
                        -- Check if target is in safe zone (already checked above, but simplified here)
                        local wouldEnterSafeZone = targetInSafeZone
                        
                        -- CRITICAL: Check if target is UNREASONABLY far away (prevents following flung players)
                        -- If distance > 10000 studs, they're probably flung - don't follow
                        if distance > 10000 then
                            print("âš ï¸ Target too far away (", math.floor(distance), "studs) - probably flung. Stopping follow.")
                            
                            -- Clean up BodyPosition
                            local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
                            if bodyPos then
                                bodyPos:Destroy()
                            end
                            
                            if targetTween then
                                targetTween:Cancel()
                                targetTween = nil
                            end
                            
                            -- In auto mode, clear target to find new one
                            if autoTargetEnabled then
                                targetPlayer = nil
                            end
                            
                            return -- Stop processing
                        end
                        
                        -- Don't tween if we're already in a safe zone OR if we'd enter one
                        if weAreInSafeZone or wouldEnterSafeZone then
                            -- Clean up any existing BodyPosition
                            local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
                            if bodyPos then
                                bodyPos:Destroy()
                            end
                        else
                            -- Safe to tween - check if we need to move closer
                            if distance > TARGET_STOP_DISTANCE then
                                -- Cancel existing tween if distance changed significantly
                                if targetTween then
                                    targetTween:Cancel()
                                end
                                
                                -- Calculate tween time based on distance and speed
                                local tweenTime = distance / TARGET_TWEEN_SPEED
                                
                                -- For vertical movement, we need to use BodyPosition or set PlatformStand
                                -- Calculate target position in 3D
                                local direction = (targetRoot.Position - rootPart.Position).Unit
                                local targetPosition = targetRoot.Position - (direction * TARGET_STOP_DISTANCE)
                                
                                -- Use BodyPosition for 3D movement (works better than tweening CFrame)
                                local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
                                if not bodyPos then
                                    bodyPos = Instance.new("BodyPosition")
                                    bodyPos.Name = "TargetBodyPosition"
                                    bodyPos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                                    bodyPos.P = 10000
                                    bodyPos.Parent = rootPart
                                end
                                
                                -- Set target position
                                bodyPos.Position = targetPosition
                                -- Adjust D (damping) based on speed - higher speed = less damping
                                bodyPos.D = math.max(100, 1000 - (TARGET_TWEEN_SPEED * 5))
                                
                                -- Debug output every 2 seconds
                                if tick() % 2 < 0.1 then
                                    local modeText = autoTargetEnabled and "[AUTO]" or "[MANUAL]"
                                    local verticalDiff = math.abs(targetRoot.Position.Y - rootPart.Position.Y)
                                    print("ðŸŽ¯", modeText, "Following:", targetPlayer.Name, "| Distance:", math.floor(distance), "studs | Vertical:", math.floor(verticalDiff), "| Speed:", TARGET_TWEEN_SPEED, "studs/s")
                                end
                            else
                                -- Within stop distance, remove BodyPosition
                                local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
                                if bodyPos then
                                    bodyPos:Destroy()
                                end
                                
                                if targetTween then
                                    targetTween:Cancel()
                                    targetTween = nil
                                end
                                
                                -- Debug output
                                if tick() % 2 < 0.1 then
                                    local modeText = autoTargetEnabled and "[AUTO]" or "[MANUAL]"
                                    print("âœ“", modeText, "At target position:", targetPlayer.Name, "| Distance:", math.floor(distance), "studs")
                                end
                            end
                        end -- Close the safe zone else block
                    else
                        -- Out of range, remove BodyPosition
                        local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
                        if bodyPos then
                            bodyPos:Destroy()
                        end
                        
                        if targetTween then
                            targetTween:Cancel()
                            targetTween = nil
                        end
                        
                        -- Debug output every 5 seconds
                        if tick() % 5 < 0.1 then
                            print("âš ï¸ Target out of range | Distance:", math.floor(distance), "studs | Max:", TARGET_MAX_DISTANCE)
                        end
                    end
                    end -- Close the "target is within bounds" else block
                end -- Close the elseif block
            end -- Close the if targetPlayer block
        else
            -- Target disabled, make sure tween is cancelled and BodyPosition removed
            if rootPart then
                local bodyPos = rootPart:FindFirstChild("TargetBodyPosition")
                if bodyPos then
                    bodyPos:Destroy()
                end
            end
            
            if targetTween then
                targetTween:Cancel()
                targetTween = nil
            end
        end
        
        -- Walkspeed enforcement
        if customWalkspeedEnabled and humanoid and humanoid.WalkSpeed ~= walkspeedValue then
            humanoid.WalkSpeed = walkspeedValue
        end
        
        -- Auto Spam Trash Talk
        if autoSpamTrashTalk then
            if tick() - lastAutoSpam >= autoSpamFrequency then
                sendTrashTalk("spam", true)
                lastAutoSpam = tick()
            end
        end
        
        -- Bhop system (works independently of custom walkspeed)
        if bhopEnabled and humanoid and rootPart then
            local moveDir = humanoid.MoveDirection
            local hzVel = Vector3.new(rootPart.Velocity.X, 0, rootPart.Velocity.Z)
            
            if bhopType == "advanced" then
                -- Advanced bhop with speed management
                if moveDir.Magnitude > 0 then
                    lastDir = moveDir.Unit
                end
                
                -- Check for sudden stops (hitting walls)
                local hzSpeedNow = hzVel.Magnitude
                if hzSpeedNow < currSpeed * 0.5 and currSpeed > baseSpeed * 1.5 then
                    currSpeed = baseSpeed
                    humanoid.WalkSpeed = baseSpeed
                end
                
                -- Handle deceleration when not moving
                if moveDir.Magnitude == 0 and currSpeed > baseSpeed then
                    -- Instant stop - kill all momentum immediately
                    currSpeed = baseSpeed
                    humanoid.WalkSpeed = baseSpeed
                    rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0)
                elseif moveDir.Magnitude == 0 then
                    currSpeed = baseSpeed
                    humanoid.WalkSpeed = baseSpeed
                    rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0)
                else
                    humanoid.WalkSpeed = currSpeed
                end
                
                -- Auto jump when on ground
                if humanoid.FloorMaterial ~= Enum.Material.Air then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            elseif bhopType == "lowhop" then
                -- LowHop: Minecraft-style low jumps with fast falling
                if moveDir.Magnitude > 0 then
                    lastDir = moveDir.Unit
                end
                
                -- Fast falling when in air (uses slider value)
                if humanoid.FloorMaterial == Enum.Material.Air then
                    -- Pull down faster using slider value
                    local currentVel = rootPart.Velocity
                    rootPart.Velocity = Vector3.new(
                        currentVel.X,
                        currentVel.Y - bhopFallSpeed * dt, -- Configurable fall speed
                        currentVel.Z
                    )
                end
                
                -- Auto jump immediately when touching ground
                if humanoid.FloorMaterial ~= Enum.Material.Air then
                    humanoid.JumpPower = lowHopJumpHeight * 7
                    humanoid.JumpHeight = lowHopJumpHeight
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
                
                -- Deceleration
                if moveDir.Magnitude == 0 and currSpeed > baseSpeed then
                    local decelRate = 30
                    currSpeed = math.max(baseSpeed, currSpeed - decelRate * dt)
                    humanoid.WalkSpeed = currSpeed
                elseif moveDir.Magnitude == 0 then
                    currSpeed = baseSpeed
                    humanoid.WalkSpeed = baseSpeed
                else
                    humanoid.WalkSpeed = currSpeed
                end
            else
                -- Simple bhop: just auto jump
                if humanoid.FloorMaterial ~= Enum.Material.Air then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        else
            -- Reset jump height/power when bhop is disabled
            if LocalPlayer.Character then
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.JumpPower = 50 -- Default
                    humanoid.JumpHeight = 7.2 -- Default
                end
            end
        end
        
-- ============================================
-- CORRECT AUTO STRAFE - ORIGIN IS CENTER, CAMERA FOLLOWS IT
-- ============================================
-- Origin part is in the center (controlled by WASD)
-- Camera focuses on origin part (not character)
-- Character constantly strafes around the origin part

        -- Auto Strafe: Origin is center, character orbits around it
        if autoStrafeEnabled and humanoid and rootPart then
            local Camera = workspace.CurrentCamera
            
            -- Initialize anchor at character position if not set
            if not autoStrafeAnchor then
                autoStrafeAnchor = rootPart.Position
                
                -- Create visible anchor part for debugging
                autoStrafeAnchorPart = Instance.new("Part")
                autoStrafeAnchorPart.Name = "AutoStrafeAnchor"
                autoStrafeAnchorPart.Size = Vector3.new(2, 2, 2)
                autoStrafeAnchorPart.Anchored = true
                autoStrafeAnchorPart.CanCollide = false
                autoStrafeAnchorPart.Material = Enum.Material.Neon
                autoStrafeAnchorPart.BrickColor = BrickColor.new("Bright red")
                autoStrafeAnchorPart.Transparency = 0.5
                autoStrafeAnchorPart.Parent = workspace
            end
            
            -- Get camera forward and right vectors (ignore Y)
            local camLook = Camera.CFrame.LookVector
            local camRight = Camera.CFrame.RightVector
            
            -- Flatten to horizontal plane
            camLook = Vector3.new(camLook.X, 0, camLook.Z).Unit
            camRight = Vector3.new(camRight.X, 0, camRight.Z).Unit
            
            -- Build movement direction from WASD relative to camera
            local forward = 0
            local right = 0
            
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then forward = forward + 1 end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then forward = forward - 1 end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then right = right + 1 end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then right = right - 1 end
            
            local inputDir = (camLook * forward + camRight * right)
            
            -- Move the ORIGIN PART based on WASD input at your actual effective speed
            if inputDir.Magnitude > 0 then
                inputDir = inputDir.Unit
                
                -- Get the ACTUAL effective speed considering all active modules
                local effectiveSpeed = humanoid.WalkSpeed
                
                -- If bhop is enabled, use current bhop speed
                if bhopEnabled and currSpeed then
                    effectiveSpeed = currSpeed
                end
                
                -- If custom walkspeed is enabled, use that
                if customWalkspeedEnabled and walkspeedValue then
                    effectiveSpeed = walkspeedValue
                end
                
                -- Move origin at FULL effective speed (this is what you're controlling)
                autoStrafeAnchor = autoStrafeAnchor + (inputDir * effectiveSpeed * dt)
            end
            
            -- Update anchor part position
            if autoStrafeAnchorPart then
                autoStrafeAnchorPart.Position = autoStrafeAnchor
            end
            
            -- CAMERA FOLLOWS THE ORIGIN PART (not the character)
            local cameraOffset = Vector3.new(0, 10, 20) -- Adjust this for camera distance/height
            Camera.CameraType = Enum.CameraType.Scriptable
            Camera.CFrame = CFrame.new(autoStrafeAnchor + cameraOffset, autoStrafeAnchor)
            
            -- Increment circular angle based on intensity (character rotates around origin)
            autoStrafeAngle = autoStrafeAngle + (autoStrafeIntensity * dt * 3)
            if autoStrafeAngle >= math.pi * 2 then
                autoStrafeAngle = 0
            end
            
            -- Calculate where character SHOULD be on the circle around origin
            local x = math.sin(autoStrafeAngle) * autoStrafeRadius
            local z = math.cos(autoStrafeAngle) * autoStrafeRadius
            
            -- Target position on the circle (around the origin part)
            local targetPos = autoStrafeAnchor + Vector3.new(x, 0, z)
            
            -- Move character to target position VERY AGGRESSIVELY
            local currentPos = Vector3.new(rootPart.Position.X, 0, rootPart.Position.Z)
            local direction = (Vector3.new(targetPos.X, 0, targetPos.Z) - currentPos)
            
            if direction.Magnitude > 0.05 then
                direction = direction.Unit
                
                -- Use ACTUAL effective walkspeed for character velocity
                local speed = humanoid.WalkSpeed
                if bhopEnabled and currSpeed then
                    speed = currSpeed
                elseif customWalkspeedEnabled and walkspeedValue then
                    speed = walkspeedValue
                end
                
                -- Calculate tangential velocity for circular motion
                local tangentAngle = autoStrafeAngle + math.pi / 2 -- 90 degrees ahead for tangent
                local tangentX = math.sin(tangentAngle)
                local tangentZ = math.cos(tangentAngle)
                local tangentDir = Vector3.new(tangentX, 0, tangentZ)
                
                -- Combine: pull toward circle position + circular strafe motion
                local finalVelocity = (direction * speed * 10) + (tangentDir * speed * autoStrafeIntensity * 4)
                
                rootPart.Velocity = Vector3.new(
                    finalVelocity.X,
                    rootPart.Velocity.Y,
                    finalVelocity.Z
                )
            end
        else
            -- Reset everything when disabled
            autoStrafeAnchor = nil
            if autoStrafeAnchorPart then
                autoStrafeAnchorPart:Destroy()
                autoStrafeAnchorPart = nil
            end
            
            -- Reset camera to normal
            local Camera = workspace.CurrentCamera
            Camera.CameraType = Enum.CameraType.Custom
        end
        
        -- Force Shift Lock enforcement
        if forceShiftLockEnabled then
            pcall(function()
                if LocalPlayer.DevEnableMouseLock ~= true then
                    LocalPlayer.DevEnableMouseLock = true
                end
            end)
        end
        if airControlEnabled and humanoid and rootPart then
            local moveDir = humanoid.MoveDirection
            
            -- Check if in air (not on ground)
            if humanoid.FloorMaterial == Enum.Material.Air and moveDir.Magnitude > 0 then
                local wishDir = moveDir.Unit
                local hzVel = Vector3.new(rootPart.Velocity.X, 0, rootPart.Velocity.Z)
                local airSpeed = math.max(
                    bhopEnabled and bhopType == "advanced" and currSpeed or walkspeedValue,
                    hzVel.Magnitude
                )
                
                -- Instant snap to direction (no inertia, full air control)
                rootPart.Velocity = Vector3.new(
                    wishDir.X * airSpeed,
                    rootPart.Velocity.Y,
                    wishDir.Z * airSpeed
                )
            end
        end
        
        -- Anti-slide: Stop momentum when not moving
        if humanoid and rootPart and antiSlideEnabled and not airControlEnabled and not bhopEnabled then
            -- Check if player is not pressing any movement keys
            local moveDirection = humanoid.MoveDirection
            
            if moveDirection.Magnitude == 0 then
                -- Player is not pressing any movement keys, kill horizontal velocity
                local velocity = rootPart.Velocity
                rootPart.Velocity = Vector3.new(0, velocity.Y, 0) -- Keep Y (jumping/falling) but zero out X and Z
            end
        end
    end
end)

-- ============================================
-- MISC TAB - TRASH TALK SYSTEM
-- ============================================

local MiscTab = FlingWindow:CreateTab({
    Name = "Misc"
})

local TrashTalkSection = MiscTab:CreateSection({
    Name = "Auto Trash Talk"
})

TrashTalkSection:AddToggle({
    Name = "Enable Trash Talk",
    Flag = "TrashTalkEnabled",
    Callback = function(value)
        trashTalkEnabled = value
        if value then
            print("ðŸ’¬ Auto Trash Talk ENABLED")
        else
            print("âœ— Auto Trash Talk DISABLED")
        end
    end
})

TrashTalkSection:AddToggle({
    Name = "Trash Talk on Kill",
    Flag = "TrashTalkOnKill",
    Value = true,
    Callback = function(value)
        trashTalkOnKill = value
        print("Trash talk on kill:", value and "ENABLED" or "DISABLED")
    end
})

TrashTalkSection:AddToggle({
    Name = "Trash Talk on Fling",
    Flag = "TrashTalkOnFling",
    Value = true,
    Callback = function(value)
        trashTalkOnFling = value
        print("Trash talk on fling:", value and "ENABLED" or "DISABLED")
    end
})

TrashTalkSection:AddSlider({
    Name = "Message Delay",
    Flag = "TrashTalkDelay",
    Value = 3,
    Min = 1,
    Max = 10,
    Format = function(Value)
        return "Delay: " .. tostring(Value) .. "s"
    end,
    Callback = function(value)
        trashTalkDelay = value
        print("Trash talk delay set to:", value, "seconds")
    end
})

TrashTalkSection:AddButton({
    Name = "Test Trash Talk",
    Callback = function()
        print("ðŸ§ª Testing trash talk...")
        lastTrashTalk = 0 -- Reset delay
        sendTrashTalk("kill")
    end
})

-- ============================================
-- VISUAL TAB - ESP SYSTEM
-- ============================================

-- ESP Variables
local espEnabled = false
local nametagsEnabled = false
local espBoxColor = Color3.fromRGB(255, 0, 0)
local nametagColor = Color3.fromRGB(255, 255, 255)
local showDistance = false
local espObjects = {}
local espBoxSize = 1

-- ESP Section
local ESPSection = VisualTab:CreateSection({
    Name = "ESP"
})

ESPSection:AddToggle({
    Name = "Bounding Boxes",
    Flag = "ESP_BoundingBoxes",
    Callback = function(value)
        espEnabled = value
        if value then
            print("âœ“ ESP ENABLED")
            createESP()
        else
            print("âœ— ESP DISABLED")
            removeESP()
        end
    end
})

ESPSection:AddToggle({
    Name = "Nametags",
    Flag = "ESP_Nametags",
    Callback = function(value)
        nametagsEnabled = value
        if value then
            print("âœ“ Nametags ENABLED")
        else
            print("âœ— Nametags DISABLED")
        end
        if updateAllESP then updateAllESP() end
    end
})

ESPSection:AddToggle({
    Name = "Show Distance",
    Flag = "ESP_ShowDistance",
    Callback = function(value)
        showDistance = value
        if updateAllESP then updateAllESP() end
    end
})

-- ESP Settings Section
local ESPSettingsSection = VisualTab:CreateSection({
    Name = "ESP Settings",
    Side = "Right"
})

ESPSettingsSection:AddSlider({
    Name = "Box Size",
    Flag = "ESP_BoxSize",
    Value = 1,
    Min = 0.5,
    Max = 3,
    Precise = 1,
    Format = function(Value)
        return "Size: " .. tostring(Value) .. "x"
    end,
    Callback = function(value)
        espBoxSize = value
        if updateAllESP then
            if updateAllESP then updateAllESP() end
        end
    end
})

ESPSettingsSection:AddColorpicker({
    Name = "Box Color",
    Flag = "ESP_BoxColor",
    Value = Color3.fromRGB(255, 0, 0),
    Callback = function(value)
        espBoxColor = value
        if updateAllESP then updateAllESP() end
    end
})

ESPSettingsSection:AddColorpicker({
    Name = "Nametag Color",
    Flag = "ESP_NametagColor",
    Value = Color3.fromRGB(255, 255, 255),
    Callback = function(value)
        nametagColor = value
        if updateAllESP then updateAllESP() end
    end
})

-- ============================================
-- Function to fling something
local function flingTarget(target)
    if not target or not target:IsA("BasePart") then
        return
    end
    
    if target.Anchored then
        return
    end
    
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Velocity = Vector3.new(
        math.random(-FLING_POWER, FLING_POWER),
        FLING_POWER,
        math.random(-FLING_POWER, FLING_POWER)
    )
    bv.Parent = target
    
    -- Send trash talk on fling
    if trashTalkOnFling then
        sendTrashTalk("fling")
    end
    
    task.delay(0.1, function()
        if bv and bv.Parent then
            bv:Destroy()
        end
        
        -- Destroy the grab connection
        local DestroyGrabLine = GrabEvents:FindFirstChild("DestroyGrabLine")
        if DestroyGrabLine then
            DestroyGrabLine:FireServer(target)
        end
    end)
end

local function killAuraTarget(rootPart)
    if not rootPart or rootPart.Anchored then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end

    -- Get the character model
    local character = rootPart.Parent
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end

    -- Force network ownership
    local SetNetworkOwner = GrabEvents:FindFirstChild("SetNetworkOwner")
    if SetNetworkOwner then
        SetNetworkOwner:FireServer(rootPart, rootPart.CFrame)
    end

    -- Create grab line to establish connection
    local myRoot = LocalPlayer.Character.HumanoidRootPart
    local offset = myRoot.CFrame:ToObjectSpace(rootPart.CFrame)
    CreateGrabLine:FireServer(rootPart, offset)

    -- Wait a moment for grab to register
    task.wait(0.1)

    print("â˜ ï¸ KillAura: EXTREME SLAMMING", character.Name, "through the ground...")
    print("   Base Velocity:", KILLAURA_BASE_VELOCITY, "| Spike Velocity:", KILLAURA_SPIKE_VELOCITY)
    
    -- METHOD: ABSOLUTELY INSANE VELOCITY to guarantee ground phasing
    
    local startTime = tick()
    local slamCount = 0
    local maxSlams = 100 -- More attempts
    
    local slamLoop = RunService.Heartbeat:Connect(function(deltaTime)
        if rootPart and rootPart.Parent and rootPart.Anchored == false then
            slamCount = slamCount + 1
            
            -- BASE VELOCITY: Use configurable value
            local extremeVelocity = Vector3.new(0, -KILLAURA_BASE_VELOCITY, 0)
            
            rootPart.Velocity = extremeVelocity
            rootPart.RotVelocity = Vector3.new(0, 0, 0)
            
            -- Also set Assembly velocities
            pcall(function()
                rootPart.AssemblyLinearVelocity = extremeVelocity
                rootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            end)
            
            -- Every 5 frames, apply NUCLEAR velocity spike
            if slamCount % 5 == 0 then
                local nuclearVelocity = Vector3.new(0, -KILLAURA_SPIKE_VELOCITY, 0)
                rootPart.Velocity = nuclearVelocity
                pcall(function()
                    rootPart.AssemblyLinearVelocity = nuclearVelocity
                end)
                print("ðŸ’¥ðŸ’¥ðŸ’¥ NUCLEAR SLAM #" .. math.floor(slamCount / 5) .. " - " .. KILLAURA_SPIKE_VELOCITY .. " velocity!")
            end
            
            -- Check if they died or fell through
            if not humanoid or humanoid.Health <= 0 or not character.Parent then
                local timeElapsed = tick() - startTime
                print("âœ“ KillAura: Target DIED after", math.floor(timeElapsed * 10) / 10, "seconds (" .. slamCount .. " slams)")
                slamLoop:Disconnect()
                
                -- Send trash talk on kill
                if trashTalkOnKill then
                    sendTrashTalk("kill")
                end
                
                -- Destroy grab connection
                local DestroyGrabLine = GrabEvents:FindFirstChild("DestroyGrabLine")
                if DestroyGrabLine then
                    DestroyGrabLine:FireServer(rootPart)
                end
                return
            end
            
            -- Check if they phased through (Y position way below ground)
            if rootPart.Position.Y < -100 then
                print("âœ“ KillAura: Target PHASED through ground! Y=" .. math.floor(rootPart.Position.Y))
            end
            
            -- Stop after max slams
            if slamCount >= maxSlams then
                print("âš ï¸ KillAura: Max slams reached (" .. maxSlams .. "), releasing grab")
                slamLoop:Disconnect()
                
                local DestroyGrabLine = GrabEvents:FindFirstChild("DestroyGrabLine")
                if DestroyGrabLine then
                    DestroyGrabLine:FireServer(rootPart)
                end
            end
        else
            -- RootPart destroyed/removed or anchored
            local timeElapsed = tick() - startTime
            print("âœ“ KillAura: Target removed after", math.floor(timeElapsed * 10) / 10, "seconds")
            slamLoop:Disconnect()
        end
    end)
    
    -- Backup timeout after 10 seconds (longer since we have more slams)
    task.delay(10, function()
        if slamLoop then
            print("âš ï¸ KillAura: 10 second timeout reached, releasing grab")
            slamLoop:Disconnect()
            
            -- Destroy grab connection
            local DestroyGrabLine = GrabEvents:FindFirstChild("DestroyGrabLine")
            if DestroyGrabLine then
                pcall(function()
                    DestroyGrabLine:FireServer(rootPart)
                end)
            end
        end
    end)
end

-- ============================================
-- ESP FUNCTIONS
-- ============================================

-- Function to create a line between two points
local function createLine(parent)
    local line = Instance.new("Part")
    line.Anchored = true
    line.CanCollide = false
    line.Material = Enum.Material.Neon
    line.Size = Vector3.new(0.05, 0.05, 1)
    line.Parent = parent
    return line
end

-- Function to update a line between two points
local function updateLine(line, pointA, pointB, color)
    local distance = (pointA - pointB).Magnitude
    line.Size = Vector3.new(0.05, 0.05, distance)
    line.CFrame = CFrame.new(pointA, pointB) * CFrame.new(0, 0, -distance / 2)
    line.Color = color
end

-- Function to create 3D bounding box
local function create3DBox()
    local boxFolder = Instance.new("Folder")
    boxFolder.Name = "ESP_Box"
    
    -- Create 12 lines for a box (4 top, 4 bottom, 4 connecting)
    local lines = {}
    for i = 1, 12 do
        lines[i] = createLine(boxFolder)
    end
    
    return boxFolder, lines
end

-- Function to update 3D box around a character
update3DBox = function(lines, character, color)
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        for _, line in pairs(lines) do
            line.Transparency = 1
        end
        return
    end
    
    -- Get character size with multiplier
    local rootPart = character.HumanoidRootPart
    local sizeX, sizeY, sizeZ = 2.5 * espBoxSize, 5 * espBoxSize, 1.5 * espBoxSize
    
    -- Calculate corners
    local cf = rootPart.CFrame
    local corners = {
        -- Bottom 4 corners
        cf * CFrame.new(-sizeX/2, -sizeY/2, -sizeZ/2).Position,
        cf * CFrame.new(sizeX/2, -sizeY/2, -sizeZ/2).Position,
        cf * CFrame.new(sizeX/2, -sizeY/2, sizeZ/2).Position,
        cf * CFrame.new(-sizeX/2, -sizeY/2, sizeZ/2).Position,
        -- Top 4 corners
        cf * CFrame.new(-sizeX/2, sizeY/2, -sizeZ/2).Position,
        cf * CFrame.new(sizeX/2, sizeY/2, -sizeZ/2).Position,
        cf * CFrame.new(sizeX/2, sizeY/2, sizeZ/2).Position,
        cf * CFrame.new(-sizeX/2, sizeY/2, sizeZ/2).Position,
    }
    
    -- Update lines
    -- Bottom square
    updateLine(lines[1], corners[1], corners[2], color)
    updateLine(lines[2], corners[2], corners[3], color)
    updateLine(lines[3], corners[3], corners[4], color)
    updateLine(lines[4], corners[4], corners[1], color)
    
    -- Top square
    updateLine(lines[5], corners[5], corners[6], color)
    updateLine(lines[6], corners[6], corners[7], color)
    updateLine(lines[7], corners[7], corners[8], color)
    updateLine(lines[8], corners[8], corners[5], color)
    
    -- Connecting lines
    updateLine(lines[9], corners[1], corners[5], color)
    updateLine(lines[10], corners[2], corners[6], color)
    updateLine(lines[11], corners[3], corners[7], color)
    updateLine(lines[12], corners[4], corners[8], color)
    
    -- Set visibility
    for _, line in pairs(lines) do
        line.Transparency = 0
    end
end

-- Function to create ESP for a player
createPlayerESP = function(player)
    if player == LocalPlayer then return end
    if espObjects[player] then return end
    
    local espObject = {
        Player = player,
        BoxFolder = nil,
        BoxLines = nil,
        Nametag = nil
    }
    
    -- Create 3D Box
    local boxFolder, boxLines = create3DBox()
    boxFolder.Parent = workspace
    espObject.BoxFolder = boxFolder
    espObject.BoxLines = boxLines
    
    -- Create BillboardGui for nametag
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Nametag"
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.Name
    nameLabel.TextColor3 = nametagColor
    nameLabel.TextStrokeTransparency = 0.5
    nameLabel.Font = Enum.Font.Code
    nameLabel.TextSize = 16
    nameLabel.Parent = billboard
    
    espObject.Nametag = billboard
    
    espObjects[player] = espObject
    
    -- Function to update ESP
    local function updateESP()
        if not player.Character then
            for _, line in pairs(boxLines) do
                line.Transparency = 1
            end
            if billboard.Parent then billboard.Parent = nil end
            return
        end
        
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then
            for _, line in pairs(boxLines) do
                line.Transparency = 1
            end
            if billboard.Parent then billboard.Parent = nil end
            return
        end
        
        -- Update 3D box
        if espEnabled then
            update3DBox(boxLines, player.Character, espBoxColor)
        else
            for _, line in pairs(boxLines) do
                line.Transparency = 1
            end
        end
        
        -- Update nametag
        if nametagsEnabled and billboard then
            billboard.Parent = rootPart
            nameLabel.TextColor3 = nametagColor
            
            -- Update distance
            if showDistance and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                nameLabel.Text = player.Name .. "\n[" .. math.floor(distance) .. " studs]"
            else
                nameLabel.Text = player.Name
            end
        else
            billboard.Parent = nil
        end
    end
    
    -- Initial update
    updateESP()
    
    -- Connect to character added
    player.CharacterAdded:Connect(function()
        task.wait(0.5)
        updateESP()
    end)
    
    return espObject
end

-- Function to remove ESP for a player
removePlayerESP = function(player)
    if espObjects[player] then
        if espObjects[player].BoxFolder then
            espObjects[player].BoxFolder:Destroy()
        end
        if espObjects[player].Nametag then
            espObjects[player].Nametag:Destroy()
        end
        espObjects[player] = nil
    end
end

-- Function to create ESP for all players
function createESP()
    for _, player in pairs(Players:GetPlayers()) do
        createPlayerESP(player)
    end
end

-- Function to remove all ESP
function removeESP()
    for player, _ in pairs(espObjects) do
        removePlayerESP(player)
    end
end

-- Function to update all ESP (overwrites placeholder)
updateAllESP = function()
    for player, espObj in pairs(espObjects) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
            
            -- Update 3D box
            if espEnabled and espObj.BoxLines then
                update3DBox(espObj.BoxLines, player.Character, espBoxColor)
            else
                if espObj.BoxLines then
                    for _, line in pairs(espObj.BoxLines) do
                        line.Transparency = 1
                    end
                end
            end
            
            -- Update nametag
            if nametagsEnabled and espObj.Nametag then
                espObj.Nametag.Parent = rootPart
                local nameLabel = espObj.Nametag:FindFirstChildOfClass("TextLabel")
                if nameLabel then
                    nameLabel.TextColor3 = nametagColor
                    
                    if showDistance and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                        nameLabel.Text = player.Name .. "\n[" .. math.floor(distance) .. " studs]"
                    else
                        nameLabel.Text = player.Name
                    end
                end
            else
                if espObj.Nametag then espObj.Nametag.Parent = nil end
            end
        end
    end
end

-- Player added/removed events
Players.PlayerAdded:Connect(function(player)
    if espEnabled or nametagsEnabled then
        task.wait(1)
        createPlayerESP(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removePlayerESP(player)
end)

-- Update ESP loop
RunService.RenderStepped:Connect(function()
    if espEnabled then
        for player, espObj in pairs(espObjects) do
            if player.Character and espObj.BoxLines then
                update3DBox(espObj.BoxLines, player.Character, espBoxColor)
            end
        end
    end
    
    if nametagsEnabled then
        for player, espObj in pairs(espObjects) do
            if showDistance and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local nameLabel = espObj.Nametag and espObj.Nametag:FindFirstChildOfClass("TextLabel")
                if nameLabel and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local rootPart = player.Character.HumanoidRootPart
                    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                    nameLabel.Text = player.Name .. "\n[" .. math.floor(distance) .. " studs]"
                end
            end
        end
    end
end)

-- ============================================
-- FLING AURA FUNCTIONS
-- ============================================

-- Function to create the fling aura ring
createAuraRing = function()
    -- Destroy old ring parts
    for _, part in pairs(auraRingParts) do
        if part then
            part:Destroy()
        end
    end
    auraRingParts = {}
    
    if not showAuraVisualization then
        return
    end
    
    repeat task.wait() until LocalPlayer.Character
    repeat task.wait() until LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    
    print("Creating fling aura ring...")
    
    if auraRingStyle == "solid" then
        -- Create a solid torus (donut shape) using a Part with a special mesh
        local solidRing = Instance.new("Part")
        solidRing.Name = "FlingAuraRingSegment"
        solidRing.Shape = Enum.PartType.Ball
        solidRing.Size = Vector3.new(1, 1, 1)
        solidRing.Transparency = 0.3
        solidRing.Color = auraRingColor
        solidRing.Material = Enum.Material.Neon
        solidRing.CanCollide = false
        solidRing.Anchored = true
        solidRing.CastShadow = false
        solidRing.Parent = workspace
        
        -- Add a SpecialMesh to create the ring/torus shape  
        local mesh = Instance.new("SpecialMesh")
        mesh.MeshType = Enum.MeshType.FileMesh
        mesh.MeshId = "rbxassetid://3270017" -- Torus mesh
        mesh.Scale = Vector3.new(AURA_RADIUS * 0.4, auraRingThickness, AURA_RADIUS * 0.4)
        mesh.Parent = solidRing
        
        table.insert(auraRingParts, solidRing)
        print("âœ“ Solid fling aura ring created!")
    else
        -- Create ring using multiple cylinder parts arranged in a circle (dots style)
        local numSegments = 36
        local segmentAngle = (math.pi * 2) / numSegments
        
        for i = 1, numSegments do
            local angle = segmentAngle * i
            local segment = Instance.new("Part")
            segment.Name = "FlingAuraRingSegment"
            segment.Shape = Enum.PartType.Cylinder
            segment.Size = Vector3.new(auraRingHeight, auraRingThickness, auraRingThickness)
            segment.Transparency = 0.3
            segment.Color = auraRingColor
            segment.Material = Enum.Material.Neon
            segment.CanCollide = false
            segment.Anchored = true
            segment.CastShadow = false
            segment.Parent = workspace
            
            table.insert(auraRingParts, segment)
        end
        print("âœ“ Fling aura ring created with", #auraRingParts, "segments! Style: dots")
    end
end

-- Function to update fling aura ring position and size
updateAuraRing = function()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    if not showAuraVisualization then
        return
    end
    
    if #auraRingParts == 0 then
        return
    end
    
    -- Update rotation if spinning is enabled
    if auraRingSpin then
        currentRotation = currentRotation + (0.02 * auraSpinSpeed)
        if currentRotation >= math.pi * 2 then
            currentRotation = 0
        end
    end
    
    local rootPart = LocalPlayer.Character.HumanoidRootPart
    local position = rootPart.Position - Vector3.new(0, rootPart.Size.Y / 2 + 2, 0)
    
    local numSegments = #auraRingParts
    local segmentAngle = (math.pi * 2) / numSegments
    
    if auraRingStyle == "solid" then
        -- Update solid ring (single torus mesh part)
        local solidRing = auraRingParts[1]
        if solidRing then
            solidRing.CFrame = CFrame.new(position) * CFrame.Angles(0, currentRotation, 0)
            solidRing.Color = auraRingColor
            
            -- Update mesh scale
            local mesh = solidRing:FindFirstChildOfClass("SpecialMesh")
            if mesh then
                mesh.Scale = Vector3.new(AURA_RADIUS * 0.4, auraRingThickness, AURA_RADIUS * 0.4)
            end
        end
    else
        -- Update dots ring (cylinder segments)
        for i, segment in pairs(auraRingParts) do
            if segment then
                local angle = segmentAngle * i + currentRotation
                local x = math.cos(angle) * AURA_RADIUS
                local z = math.sin(angle) * AURA_RADIUS
                
                local segmentPos = position + Vector3.new(x, 0, z)
                segment.CFrame = CFrame.new(segmentPos) * CFrame.Angles(0, angle, math.rad(90))
                segment.Size = Vector3.new(auraRingHeight, auraRingThickness, auraRingThickness)
                segment.Color = auraRingColor
            end
        end
    end
end

-- Function to create the fling aura
createAura = function()
    createAuraRing()
    
    print("Creating fling aura scanning system...")
    
    -- Active scanning
    local lastCheck = 0
    local recentlyFlung = {}
    
    auraConnection = RunService.RenderStepped:Connect(function()
        if not auraEnabled then return end
        
        if tick() - lastCheck < 0.2 then 
            updateAuraRing()
            return 
        end
        lastCheck = tick()
        
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local myPos = LocalPlayer.Character.HumanoidRootPart.Position
        
        -- Check all players
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                local theirRoot = player.Character:FindFirstChild("HumanoidRootPart")
                
                if humanoid and humanoid.Health > 0 and theirRoot then
                    local distance = (theirRoot.Position - myPos).Magnitude
                    
                    -- Check if player is in a safe zone (PlayersInPlots folder)
                    local inSafeZone = false
                    local playersInPlotsFolder = workspace:FindFirstChild("PlotItems")
                    if playersInPlotsFolder then
                        playersInPlotsFolder = playersInPlotsFolder:FindFirstChild("PlayersInPlots")
                        if playersInPlotsFolder and player.Character.Parent == playersInPlotsFolder then
                            inSafeZone = true
                        end
                    end
                    
                    if distance <= AURA_RADIUS and not inSafeZone then
                        if not recentlyFlung[player] or tick() - recentlyFlung[player] > 1 then
                            print("ðŸŽ¯ FLINGING Player:", player.Name)
                            recentlyFlung[player] = tick()
                            
                            -- Set network ownership
                            local SetNetworkOwner = GrabEvents:FindFirstChild("SetNetworkOwner")
                            if SetNetworkOwner then
                                SetNetworkOwner:FireServer(theirRoot, theirRoot.CFrame)
                            end
                            
                            -- Create grab line
                            local myRoot = LocalPlayer.Character.HumanoidRootPart
                            local offsetCFrame = myRoot.CFrame:ToObjectSpace(theirRoot.CFrame)
                            CreateGrabLine:FireServer(theirRoot, offsetCFrame)
                            
                            task.wait(0.05)
                            flingTarget(theirRoot)
                        end
                    end
                end
            end
        end

        -- Check for parts
        local region = Region3.new(myPos - Vector3.new(AURA_RADIUS, AURA_RADIUS, AURA_RADIUS), 
                                    myPos + Vector3.new(AURA_RADIUS, AURA_RADIUS, AURA_RADIUS))
        region = region:ExpandToGrid(4)
        
        local parts = workspace:FindPartsInRegion3(region, LocalPlayer.Character, 100)
        
        for _, part in pairs(parts) do
            if part:IsA("BasePart") and not part.Anchored then
                if not part:IsDescendantOf(LocalPlayer.Character) and not part.Name:match("AuraRing") then
                    local partDistance = (part.Position - myPos).Magnitude
                    
                    if partDistance <= AURA_RADIUS then
                        if not recentlyFlung[part] or tick() - recentlyFlung[part] > 1 then
                            recentlyFlung[part] = tick()
                            
                            local SetNetworkOwner = GrabEvents:FindFirstChild("SetNetworkOwner")
                            if SetNetworkOwner then
                                SetNetworkOwner:FireServer(part, part.CFrame)
                            end
                            
                            local myRoot = LocalPlayer.Character.HumanoidRootPart
                            local offsetCFrame = myRoot.CFrame:ToObjectSpace(part.CFrame)
                            CreateGrabLine:FireServer(part, offsetCFrame)
                            
                            task.wait(0.05)
                            flingTarget(part)
                        end
                    end
                end
            end
        end
        
        -- Update aura ring position
        updateAuraRing()
    end)
end

-- Function to destroy the fling aura
destroyAura = function()
    for _, part in pairs(auraRingParts) do
        if part then
            part:Destroy()
        end
    end
    auraRingParts = {}
    
    if auraConnection then
        auraConnection:Disconnect()
        auraConnection = nil
    end
    print("âœ— Fling Aura destroyed")
end

-- ============================================
-- KILLAURA FUNCTIONS (COMPLETELY SEPARATE)
-- ============================================

-- Function to create the KillAura ring
createKillAuraRing = function()
    -- Destroy old ring parts
    for _, part in pairs(killAuraRingParts) do
        if part then
            part:Destroy()
        end
    end
    killAuraRingParts = {}
    
    if not showKillAuraVisualization then
        return
    end
    
    repeat task.wait() until LocalPlayer.Character
    repeat task.wait() until LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    
    print("Creating KillAura ring...")
    
    if killAuraRingStyle == "solid" then
        local solidRing = Instance.new("Part")
        solidRing.Name = "KillAuraRingSegment"
        solidRing.Shape = Enum.PartType.Ball
        solidRing.Size = Vector3.new(1, 1, 1)
        solidRing.Transparency = 0.3
        solidRing.Color = killAuraRingColor
        solidRing.Material = Enum.Material.Neon
        solidRing.CanCollide = false
        solidRing.Anchored = true
        solidRing.CastShadow = false
        solidRing.Parent = workspace
        
        local mesh = Instance.new("SpecialMesh")
        mesh.MeshType = Enum.MeshType.FileMesh
        mesh.MeshId = "rbxassetid://3270017"
        mesh.Scale = Vector3.new(KILLAURA_RADIUS * 0.4, killAuraRingThickness, KILLAURA_RADIUS * 0.4)
        mesh.Parent = solidRing
        
        table.insert(killAuraRingParts, solidRing)
        print("âœ“ Solid KillAura ring created!")
    else
        local numSegments = 36
        local segmentAngle = (math.pi * 2) / numSegments
        
        for i = 1, numSegments do
            local angle = segmentAngle * i
            local segment = Instance.new("Part")
            segment.Name = "KillAuraRingSegment"
            segment.Shape = Enum.PartType.Cylinder
            segment.Size = Vector3.new(killAuraRingHeight, killAuraRingThickness, killAuraRingThickness)
            segment.Transparency = 0.3
            segment.Color = killAuraRingColor
            segment.Material = Enum.Material.Neon
            segment.CanCollide = false
            segment.Anchored = true
            segment.CastShadow = false
            segment.Parent = workspace
            
            table.insert(killAuraRingParts, segment)
        end
        print("âœ“ KillAura ring created with", #killAuraRingParts, "segments! Style: dots")
    end
end

-- Function to update KillAura ring position and size
updateKillAuraRing = function()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    if not showKillAuraVisualization then
        return
    end
    
    if #killAuraRingParts == 0 then
        return
    end
    
    -- Update rotation if spinning is enabled
    if killAuraRingSpin then
        killAuraCurrentRotation = killAuraCurrentRotation + (0.02 * killAuraSpinSpeed)
        if killAuraCurrentRotation >= math.pi * 2 then
            killAuraCurrentRotation = 0
        end
    end
    
    local rootPart = LocalPlayer.Character.HumanoidRootPart
    local position = rootPart.Position - Vector3.new(0, rootPart.Size.Y / 2 + 2, 0)
    
    local numSegments = #killAuraRingParts
    local segmentAngle = (math.pi * 2) / numSegments
    
    if killAuraRingStyle == "solid" then
        local solidRing = killAuraRingParts[1]
        if solidRing then
            solidRing.CFrame = CFrame.new(position) * CFrame.Angles(0, killAuraCurrentRotation, 0)
            solidRing.Color = killAuraRingColor
            
            local mesh = solidRing:FindFirstChildOfClass("SpecialMesh")
            if mesh then
                mesh.Scale = Vector3.new(KILLAURA_RADIUS * 0.4, killAuraRingThickness, KILLAURA_RADIUS * 0.4)
            end
        end
    else
        for i, segment in pairs(killAuraRingParts) do
            if segment then
                local angle = segmentAngle * i + killAuraCurrentRotation
                local x = math.cos(angle) * KILLAURA_RADIUS
                local z = math.sin(angle) * KILLAURA_RADIUS
                
                local segmentPos = position + Vector3.new(x, 0, z)
                segment.CFrame = CFrame.new(segmentPos) * CFrame.Angles(0, angle, math.rad(90))
                segment.Size = Vector3.new(killAuraRingHeight, killAuraRingThickness, killAuraRingThickness)
                segment.Color = killAuraRingColor
            end
        end
    end
end

-- Function to create the KillAura
createKillAura = function()
    createKillAuraRing()
    
    print("Creating KillAura scanning system...")
    
    local lastCheck = 0
    
    killAuraConnection = RunService.RenderStepped:Connect(function()
        if not killAuraEnabled then return end
        
        if tick() - lastCheck < 0.2 then 
            updateKillAuraRing()
            return 
        end
        lastCheck = tick()
        
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local myPos = LocalPlayer.Character.HumanoidRootPart.Position
        
        -- KillAura player check
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                local root = player.Character:FindFirstChild("HumanoidRootPart")
    
                if humanoid and humanoid.Health > 0 and root then
                    local distance = (root.Position - myPos).Magnitude
                    
                    -- Check if player is in a safe zone (PlayersInPlots folder)
                    local inSafeZone = false
                    local playersInPlotsFolder = workspace:FindFirstChild("PlotItems")
                    if playersInPlotsFolder then
                        playersInPlotsFolder = playersInPlotsFolder:FindFirstChild("PlayersInPlots")
                        if playersInPlotsFolder and player.Character.Parent == playersInPlotsFolder then
                            inSafeZone = true
                        end
                    end
                    
                    if distance <= KILLAURA_RADIUS and not inSafeZone then
                        if not recentlyKilled[player] or tick() - recentlyKilled[player] > 1 then
                            print("â˜ ï¸ KILLING Player:", player.Name)
                            recentlyKilled[player] = tick()
                            killAuraTarget(root)
                        end
                    end
                end
            end
        end
        
        -- Update KillAura ring position
        updateKillAuraRing()
    end)
end

-- Function to destroy the KillAura
destroyKillAura = function()
    for _, part in pairs(killAuraRingParts) do
        if part then
            part:Destroy()
        end
    end
    killAuraRingParts = {}
    
    if killAuraConnection then
        killAuraConnection:Disconnect()
        killAuraConnection = nil
    end
    print("âœ— KillAura destroyed")
end

-- Listen for instant fling (manual grabs)
CreateGrabLine.OnClientEvent:Connect(function(player, grabbedPart, offset)
    if player == LocalPlayer and instantFlingEnabled then
        print("ðŸŽ¯ Grabbed:", grabbedPart.Name)
        
        task.wait(0.05)
        
        -- Check if it's a player
        local character = grabbedPart.Parent
        if character and character:FindFirstChild("Humanoid") then
            local targetPlayer = Players:GetPlayerFromCharacter(character)
            if targetPlayer then
                print("ðŸŽ¯ This is player:", targetPlayer.Name)
                local theirRoot = character:FindFirstChild("HumanoidRootPart")
                if theirRoot then
                    flingTarget(theirRoot)
                end
                return
            end
        end
        
        flingTarget(grabbedPart)
    end
end)

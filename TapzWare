-- ============================================
-- FLING SCRIPT WITH UI LIBRARY
-- ============================================
-- IMPORTANT: This MUST be executed as a LocalScript!
-- Place in: StarterPlayer > StarterPlayerScripts
-- Or execute via: Executor (Synapse, KRNL, etc.)
-- ============================================

print("=== SCRIPT STARTING ===")

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

print("LocalPlayer found:", LocalPlayer.Name)

-- Wait for character
if not LocalPlayer.Character then
    LocalPlayer.CharacterAdded:Wait()
end
print("Character found:", LocalPlayer.Character.Name)

-- Load UI Library
print("Loading UI Library...")
local success, library = pcall(function()
    return loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)()
end)

if not success then
    warn("Failed to load UI library:", library)
    return
end

print("UI Library loaded successfully!")
local Wait = library.subs.Wait

-- Force third person camera
LocalPlayer.CameraMode = Enum.CameraMode.Classic
LocalPlayer.CameraMaxZoomDistance = 128
LocalPlayer.CameraMinZoomDistance = 12 -- Set to 12 first to force third person
task.wait(0.1) -- Brief delay
LocalPlayer.CameraMinZoomDistance = 0.5 -- Then back to 0.5 to allow full zoom

-- Settings
local FLING_POWER = 500
local instantFlingEnabled = false
local auraEnabled = false
local AURA_RADIUS = 15

-- Aura visualization settings
local showAuraVisualization = true
local auraRingColor = Color3.fromRGB(255, 0, 127)
local auraRingThickness = 0.5
local auraRingHeight = 0.3
local auraRingSpin = false
local auraSpinSpeed = 1
local auraRingStyle = "dots" -- "dots" or "solid"
local currentRotation = 0

-- Aura system variables (declared early to prevent nil errors)
local auraRingParts = {}
local auraConnection = nil

-- Walkspeed variables
local customWalkspeedEnabled = false
local walkspeedValue = 16
local antiSlideEnabled = true -- Always enabled with custom walkspeed

-- Air control variable
local airControlEnabled = false

-- Bhop variables
local bhopEnabled = false
local bhopType = "advanced" -- "advanced" or "simple" or "lowhop"
local baseSpeed = 20
local speedCap = 70
local currSpeed = baseSpeed
local lastDir = Vector3.new(0, 0, 0)
local bhopJumpBoost = 2.0 -- Multiplier for jump speed boost (Advanced mode only)
local lowHopJumpHeight = 3 -- Jump height for LowHop mode
local bhopFallSpeed = 50 -- Fall speed for LowHop mode

-- Infinite Jump variable
local infiniteJumpEnabled = false
local infiniteJumpPower = 50 -- Power of infinite jumps

-- Auto Strafe variables
local autoStrafeEnabled = false
local autoStrafeIntensity = 1 -- Speed of rotation (1-10)
local autoStrafeAngle = 0 -- Current angle for circular motion
local autoStrafeAnchor = nil -- The center point to circle around
local autoStrafeAnchorPart = nil -- Visible part for debugging
local autoStrafeRadius = 5 -- Distance from anchor to circle around

-- Force Shift Lock variable
local forceShiftLockEnabled = false

-- Wait for the grab events
print("Waiting for GrabEvents...")
local GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents", 10)
if not GrabEvents then
    warn("GrabEvents not found! This game may not have grab mechanics.")
else
    print("GrabEvents found!")
end

local CreateGrabLine = GrabEvents and GrabEvents:WaitForChild("CreateGrabLine", 5)
if CreateGrabLine then
    print("CreateGrabLine found!")
else
    warn("CreateGrabLine not found!")
end

-- Create Window
print("Creating UI Window...")
local FlingWindow = library:CreateWindow({
    Name = "TapzWare",
    Themeable = {
        Info = "Fling Script"
    }
})
print("UI Window created! Press RightShift to toggle menu")

-- ============================================
-- PLACEHOLDER FUNCTIONS (defined properly later)
-- ============================================
-- These prevent nil errors in callbacks
local updateAllESP = function() end
local createPlayerESP = function() end
local removePlayerESP = function() end
local update3DBox = function() end
local updateAuraRing = function() end
local createAuraRing = function() end
local createAura = function() end
local destroyAura = function() end

-- Create Tabs
local FlingTab = FlingWindow:CreateTab({
    Name = "Fling"
})

local PlayerTab = FlingWindow:CreateTab({
    Name = "Player"
})

local VisualTab = FlingWindow:CreateTab({
    Name = "Visual"
})

-- ============================================
-- FLING TAB
-- ============================================
local FlingSection = FlingTab:CreateSection({
    Name = "Fling Options"
})

-- Add Toggles
FlingSection:AddToggle({
    Name = "Instant Fling",
    Flag = "InstantFling",
    Callback = function(value)
        instantFlingEnabled = value
        if value then
            print("âœ“ Instant Fling ENABLED")
        else
            print("âœ— Instant Fling DISABLED")
        end
    end
})

FlingSection:AddToggle({
    Name = "Fling Aura",
    Flag = "FlingAura",
    Callback = function(value)
        auraEnabled = value
        if value then
            print("âœ“ Fling Aura ENABLED")
            createAura()
        else
            print("âœ— Fling Aura DISABLED")
            destroyAura()
        end
    end
})

-- Settings Section
local FlingSettingsSection = FlingTab:CreateSection({
    Name = "Settings",
    Side = "Right"
})

FlingSettingsSection:AddSlider({
    Name = "Aura Radius",
    Flag = "AuraRadius",
    Value = 15,
    Min = 5,
    Max = 50,
    Format = function(Value)
        return "Radius: " .. tostring(Value)
    end,
    Callback = function(value)
        AURA_RADIUS = value
        print("Aura Radius set to:", value)
        
        -- Update aura visual immediately if it exists
        if auraRingParts and #auraRingParts > 0 then
            updateAuraRing()
            print("âœ“ Aura ring updated!")
        end
    end
})

FlingSettingsSection:AddSlider({
    Name = "Fling Power",
    Flag = "FlingPower",
    Value = 500,
    Min = 100,
    Max = 10000,
    Format = function(Value)
        return "Power: " .. tostring(Value)
    end,
    Callback = function(value)
        FLING_POWER = value
        print("Fling Power set to:", value, "- will apply to next fling")
    end
})

-- Aura Visualization Section
local AuraVisualSection = FlingTab:CreateSection({
    Name = "Aura Visualization",
    Side = "Right"
})

AuraVisualSection:AddToggle({
    Name = "Show Aura Ring",
    Flag = "ShowAuraVisualization",
    Value = true,
    Callback = function(value)
        showAuraVisualization = value
        
        if value then
            -- Recreate the ring if aura is enabled
            if auraEnabled then
                createAuraRing()
            end
            print("âœ“ Aura visualization ENABLED")
        else
            -- Hide the ring
            for _, part in pairs(auraRingParts) do
                if part then
                    part:Destroy()
                end
            end
            auraRingParts = {}
            print("âœ— Aura visualization DISABLED")
        end
    end
})

AuraVisualSection:AddColorpicker({
    Name = "Ring Color",
    Flag = "AuraRingColor",
    Value = Color3.fromRGB(255, 0, 127),
    Callback = function(value)
        auraRingColor = value
        print("Ring color changed to:", value)
        
        -- Update ring color immediately
        if auraRingParts and #auraRingParts > 0 then
            for _, part in pairs(auraRingParts) do
                if part then
                    part.Color = value
                end
            end
            print("âœ“ Ring color updated!")
        end
    end
})

print("DEBUG: Ring Thickness slider starting...")

AuraVisualSection:AddSlider({
    Name = "Ring Thickness",
    Flag = "RingThickness",
    Value = 0.5,
    Min = 0.1,
    Max = 2,
    Format = function(Value)
        return "Thickness: " .. tostring(Value)
    end,
    Callback = function(value)
        auraRingThickness = value
        print("Ring thickness set to:", value)
        
        -- Update ring immediately
        if auraRingParts and #auraRingParts > 0 then
            updateAuraRing()
            print("âœ“ Ring thickness updated!")
        end
    end
})

print("DEBUG: Ring Height slider starting...")

print("DEBUG: Ring Height slider starting...")

AuraVisualSection:AddSlider({
    Name = "Ring Height",
    Flag = "RingHeight",
    Value = 0.3,
    Min = 0.1,
    Max = 2,
    Format = function(Value)
        return "Height: " .. tostring(Value)
    end,
    Callback = function(value)
        auraRingHeight = value
        print("Ring height set to:", value)
        
        -- Update ring immediately
        if auraRingParts and #auraRingParts > 0 then
            updateAuraRing()
            print("âœ“ Ring height updated!")
        end
    end
})

print("DEBUG: Aura visualization section complete!")

-- Ring Animation Section
local RingAnimationSection = FlingTab:CreateSection({
    Name = "Ring Animation",
    Side = "Right"
})

RingAnimationSection:AddToggle({
    Name = "Spin Ring",
    Flag = "SpinRing",
    Value = false,
    Callback = function(value)
        auraRingSpin = value
        if value then
            print("âœ“ Ring spinning ENABLED")
        else
            print("âœ— Ring spinning DISABLED")
            currentRotation = 0 -- Reset rotation
        end
    end
})

RingAnimationSection:AddSlider({
    Name = "Spin Speed",
    Flag = "SpinSpeed",
    Value = 1,
    Min = 0.1,
    Max = 5,
    Format = function(Value)
        return "Speed: " .. tostring(Value) .. "x"
    end,
    Callback = function(value)
        auraSpinSpeed = value
        print("Spin speed set to:", value .. "x")
    end
})

RingAnimationSection:AddDropdown({
    Name = "Ring Style",
    Flag = "RingStyle",
    List = {"Dots", "Solid"},
    Default = "Dots",
    Callback = function(value)
        local newStyle = value:lower()
        if newStyle ~= auraRingStyle then
            auraRingStyle = newStyle
            print("Ring style changed to:", value)
            
            -- Recreate ring with new style if it exists
            if auraRingParts and #auraRingParts > 0 and showAuraVisualization then
                createAuraRing()
                print("âœ“ Ring recreated with new style!")
            end
        end
    end
})

-- ============================================
-- ============================================
-- PLAYER TAB
-- ============================================
local PlayerMovementSection = PlayerTab:CreateSection({
    Name = "Movement"
})

PlayerMovementSection:AddToggle({
    Name = "Force Shift Lock",
    Flag = "ForceShiftLock",
    Callback = function(value)
        forceShiftLockEnabled = value
        pcall(function()
            if value then
                LocalPlayer.DevEnableMouseLock = true
                print("âœ“ Shift Lock ENABLED")
            else
                LocalPlayer.DevEnableMouseLock = false
                print("âœ— Shift Lock DISABLED")
            end
        end)
    end
})

PlayerMovementSection:AddToggle({
    Name = "Custom Walkspeed",
    Flag = "CustomWalkspeed",
    Callback = function(value)
        customWalkspeedEnabled = value
        if value then
            print("âœ“ Custom Walkspeed ENABLED")
            print("DEBUG: Setting walkspeed to:", walkspeedValue)
            -- Apply immediately
            if LocalPlayer.Character then
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    print("DEBUG: Current WalkSpeed:", humanoid.WalkSpeed)
                    humanoid.WalkSpeed = walkspeedValue
                    print("DEBUG: After setting WalkSpeed:", humanoid.WalkSpeed)
                end
            end
        else
            print("âœ— Custom Walkspeed DISABLED")
            -- Reset to default
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = 16
            end
        end
    end
})

PlayerMovementSection:AddToggle({
    Name = "Air Control",
    Flag = "AirControl",
    Callback = function(value)
        airControlEnabled = value
        if value then
            print("âœ“ Air Control ENABLED")
        else
            print("âœ— Air Control DISABLED")
        end
    end
})

PlayerMovementSection:AddToggle({
    Name = "Bhop",
    Flag = "Bhop",
    Callback = function(value)
        bhopEnabled = value
        if value then
            print("âœ“ Bhop ENABLED")
        else
            print("âœ— Bhop DISABLED")
        end
    end
})

PlayerMovementSection:AddToggle({
    Name = "Infinite Jump",
    Flag = "InfiniteJump",
    Callback = function(value)
        infiniteJumpEnabled = value
        if value then
            print("âœ“ Infinite Jump ENABLED")
        else
            print("âœ— Infinite Jump DISABLED")
        end
    end
})

PlayerMovementSection:AddToggle({
    Name = "Auto Strafe",
    Flag = "AutoStrafe",
    Callback = function(value)
        autoStrafeEnabled = value
        if value then
            print("âœ“ Auto Strafe ENABLED")
        else
            print("âœ— Auto Strafe DISABLED")
        end
    end
})

-- Movement Settings
local PlayerSettingsSection = PlayerTab:CreateSection({
    Name = "Settings",
    Side = "Right"
})

PlayerSettingsSection:AddSlider({
    Name = "Walkspeed Value",
    Flag = "Walkspeed",
    Value = 16,
    Min = 16,
    Max = 200,
    Format = function(Value)
        return "Walkspeed: " .. tostring(Value)
    end,
    Callback = function(value)
        walkspeedValue = value
        print("Walkspeed set to:", value)
        
        -- Apply immediately if custom walkspeed is enabled
        if customWalkspeedEnabled and LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = value
            end
        end
    end
})

PlayerSettingsSection:AddDropdown({
    Name = "Bhop Type",
    Flag = "BhopType",
    List = {"Advanced", "Simple", "LowHop"},
    Default = "Advanced",
    Callback = function(value)
        bhopType = value:lower()
        print("Bhop type set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "Advanced: Jump Speed Boost",
    Flag = "JumpSpeedBoost",
    Value = 2.0,
    Min = 0.5,
    Max = 10,
    Format = function(Value)
        return "Jump Boost: " .. tostring(Value) .. "x"
    end,
    Callback = function(value)
        bhopJumpBoost = value
        print("Jump speed boost set to:", value .. "x")
    end
})

PlayerSettingsSection:AddSlider({
    Name = "LowHop: Jump Height",
    Flag = "LowHopJumpHeight",
    Value = 3,
    Min = 1,
    Max = 10,
    Format = function(Value)
        return "LowHop Height: " .. tostring(Value)
    end,
    Callback = function(value)
        lowHopJumpHeight = value
        print("LowHop jump height set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "LowHop: Fall Speed",
    Flag = "LowHopFallSpeed",
    Value = 50,
    Min = 0,
    Max = 500,
    Format = function(Value)
        return "LowHop Fall: " .. tostring(Value)
    end,
    Callback = function(value)
        bhopFallSpeed = value
        print("LowHop fall speed set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "Auto Strafe: Circle Radius",
    Flag = "AutoStrafeRadius",
    Value = 5,
    Min = 1,
    Max = 20,
    Format = function(Value)
        return "Strafe Radius: " .. tostring(Value)
    end,
    Callback = function(value)
        autoStrafeRadius = value
        print("Auto strafe radius set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "Auto Strafe: Rotation Speed",
    Flag = "AutoStrafeSpeed",
    Value = 1,
    Min = 0.1,
    Max = 10,
    Format = function(Value)
        return "Strafe Speed: " .. tostring(Value)
    end,
    Callback = function(value)
        autoStrafeIntensity = value
        print("Auto strafe speed set to:", value)
    end
})

PlayerSettingsSection:AddSlider({
    Name = "Infinite Jump: Power",
    Flag = "InfiniteJumpPower",
    Value = 50,
    Min = 10,
    Max = 200,
    Format = function(Value)
        return "Jump Power: " .. tostring(Value)
    end,
    Callback = function(value)
        infiniteJumpPower = value
        print("Infinite jump power set to:", value)
    end
})

-- Walkspeed system
local walkspeedConnection = nil

local function setupWalkspeed(character)
    if walkspeedConnection then
        walkspeedConnection:Disconnect()
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    
    -- Listen for any changes to WalkSpeed and override them
    walkspeedConnection = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if customWalkspeedEnabled then
            -- The game just changed walkspeed, override it back
            if humanoid.WalkSpeed ~= walkspeedValue then
                humanoid.WalkSpeed = walkspeedValue
                print("DEBUG: Overriding game walkspeed, forcing to:", walkspeedValue)
            end
        end
    end)
    
    -- Also apply immediately
    if customWalkspeedEnabled then
        humanoid.WalkSpeed = walkspeedValue
    end
end

-- Setup for current character
if LocalPlayer.Character then
    setupWalkspeed(LocalPlayer.Character)
end

-- Setup for future characters
LocalPlayer.CharacterAdded:Connect(setupWalkspeed)

-- Bhop jump handler
LocalPlayer.CharacterAdded:Connect(function(character)
    local humanoid = character:WaitForChild("Humanoid")
    
    humanoid.Jumping:Connect(function()
        if bhopEnabled then
            if bhopType == "advanced" then
                -- Advanced bhop: speed boost on jump using slider value
                currSpeed = math.min(currSpeed + bhopJumpBoost, speedCap)
                humanoid.WalkSpeed = currSpeed
                print("Jump boost! Speed:", currSpeed)
            elseif bhopType == "lowhop" then
                -- LowHop: speed boost on jump using slider value
                currSpeed = math.min(currSpeed + 1.5, speedCap)
                humanoid.WalkSpeed = currSpeed
                
                -- Use slider value for jump height
                humanoid.JumpPower = lowHopJumpHeight * 7 -- Convert to JumpPower
                humanoid.JumpHeight = lowHopJumpHeight
                print("LowHop! Speed:", currSpeed)
            end
        end
    end)
end)

-- Apply to current character if exists
if LocalPlayer.Character then
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.Jumping:Connect(function()
            if bhopEnabled then
                if bhopType == "advanced" then
                    currSpeed = math.min(currSpeed + bhopJumpBoost, speedCap)
                    humanoid.WalkSpeed = currSpeed
                    print("Jump boost! Speed:", currSpeed)
                elseif bhopType == "lowhop" then
                    currSpeed = math.min(currSpeed + 1.5, speedCap)
                    humanoid.WalkSpeed = currSpeed
                    humanoid.JumpPower = lowHopJumpHeight * 7
                    humanoid.JumpHeight = lowHopJumpHeight
                    print("LowHop! Speed:", currSpeed)
                end
            end
        end)
    end
end

-- Infinite Jump system
local UserInputService = game:GetService("UserInputService")

UserInputService.JumpRequest:Connect(function()
    if infiniteJumpEnabled and LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            -- Apply custom jump power
            local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                rootPart.Velocity = Vector3.new(
                    rootPart.Velocity.X,
                    infiniteJumpPower,
                    rootPart.Velocity.Z
                )
            end
        end
    end
end)

-- Backup loop in case the event doesn't catch everything
RunService.Heartbeat:Connect(function(dt)
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        -- Walkspeed enforcement
        if customWalkspeedEnabled and humanoid and humanoid.WalkSpeed ~= walkspeedValue then
            humanoid.WalkSpeed = walkspeedValue
        end
        
        -- Bhop system (works independently of custom walkspeed)
        if bhopEnabled and humanoid and rootPart then
            local moveDir = humanoid.MoveDirection
            local hzVel = Vector3.new(rootPart.Velocity.X, 0, rootPart.Velocity.Z)
            
            if bhopType == "advanced" then
                -- Advanced bhop with speed management
                if moveDir.Magnitude > 0 then
                    lastDir = moveDir.Unit
                end
                
                -- Check for sudden stops (hitting walls)
                local hzSpeedNow = hzVel.Magnitude
                if hzSpeedNow < currSpeed * 0.5 and currSpeed > baseSpeed * 1.5 then
                    currSpeed = baseSpeed
                    humanoid.WalkSpeed = baseSpeed
                end
                
                -- Handle deceleration when not moving
                if moveDir.Magnitude == 0 and currSpeed > baseSpeed then
                    -- Instant stop - kill all momentum immediately
                    currSpeed = baseSpeed
                    humanoid.WalkSpeed = baseSpeed
                    rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0)
                elseif moveDir.Magnitude == 0 then
                    currSpeed = baseSpeed
                    humanoid.WalkSpeed = baseSpeed
                    rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0)
                else
                    humanoid.WalkSpeed = currSpeed
                end
                
                -- Auto jump when on ground
                if humanoid.FloorMaterial ~= Enum.Material.Air then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            elseif bhopType == "lowhop" then
                -- LowHop: Minecraft-style low jumps with fast falling
                if moveDir.Magnitude > 0 then
                    lastDir = moveDir.Unit
                end
                
                -- Fast falling when in air (uses slider value)
                if humanoid.FloorMaterial == Enum.Material.Air then
                    -- Pull down faster using slider value
                    local currentVel = rootPart.Velocity
                    rootPart.Velocity = Vector3.new(
                        currentVel.X,
                        currentVel.Y - bhopFallSpeed * dt, -- Configurable fall speed
                        currentVel.Z
                    )
                end
                
                -- Auto jump immediately when touching ground
                if humanoid.FloorMaterial ~= Enum.Material.Air then
                    humanoid.JumpPower = lowHopJumpHeight * 7
                    humanoid.JumpHeight = lowHopJumpHeight
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
                
                -- Deceleration
                if moveDir.Magnitude == 0 and currSpeed > baseSpeed then
                    local decelRate = 30
                    currSpeed = math.max(baseSpeed, currSpeed - decelRate * dt)
                    humanoid.WalkSpeed = currSpeed
                elseif moveDir.Magnitude == 0 then
                    currSpeed = baseSpeed
                    humanoid.WalkSpeed = baseSpeed
                else
                    humanoid.WalkSpeed = currSpeed
                end
            else
                -- Simple bhop: just auto jump
                if humanoid.FloorMaterial ~= Enum.Material.Air then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        else
            -- Reset jump height/power when bhop is disabled
            if LocalPlayer.Character then
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.JumpPower = 50 -- Default
                    humanoid.JumpHeight = 7.2 -- Default
                end
            end
        end
        
        -- Auto Strafe: Circular strafing around a moving anchor point
        if autoStrafeEnabled and humanoid and rootPart then
            local moveDir = humanoid.MoveDirection
            local Camera = workspace.CurrentCamera
            
            -- Initialize anchor at character position if not set
            if not autoStrafeAnchor then
                autoStrafeAnchor = rootPart.Position
                
                -- Create visible anchor part for debugging
                autoStrafeAnchorPart = Instance.new("Part")
                autoStrafeAnchorPart.Name = "AutoStrafeAnchor"
                autoStrafeAnchorPart.Size = Vector3.new(2, 2, 2)
                autoStrafeAnchorPart.Anchored = true
                autoStrafeAnchorPart.CanCollide = false
                autoStrafeAnchorPart.Material = Enum.Material.Neon
                autoStrafeAnchorPart.BrickColor = BrickColor.new("Bright red")
                autoStrafeAnchorPart.Transparency = 0.5
                autoStrafeAnchorPart.Parent = workspace
            end
            
            -- Move the anchor based on player input relative to CAMERA look direction
            if moveDir.Magnitude > 0 then
                -- Get camera forward and right vectors (ignore Y)
                local camLook = Camera.CFrame.LookVector
                local camRight = Camera.CFrame.RightVector
                
                -- Flatten to horizontal plane
                camLook = Vector3.new(camLook.X, 0, camLook.Z).Unit
                camRight = Vector3.new(camRight.X, 0, camRight.Z).Unit
                
                -- Build movement direction from WASD relative to camera
                local forward = 0
                local right = 0
                
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then forward = forward + 1 end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then forward = forward - 1 end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then right = right + 1 end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then right = right - 1 end
                
                local inputDir = (camLook * forward + camRight * right)
                if inputDir.Magnitude > 0 then
                    inputDir = inputDir.Unit
                    
                    -- Use actual walkspeed value for anchor movement
                    local moveSpeed = customWalkspeedEnabled and walkspeedValue or humanoid.WalkSpeed
                    autoStrafeAnchor = autoStrafeAnchor + (inputDir * moveSpeed * dt)
                end
            end
            
            -- Update anchor part position
            if autoStrafeAnchorPart then
                autoStrafeAnchorPart.Position = autoStrafeAnchor
            end
            
            -- Increment circular angle
            autoStrafeAngle = autoStrafeAngle + (autoStrafeIntensity * dt)
            if autoStrafeAngle >= math.pi * 2 then
                autoStrafeAngle = 0
            end
            
            -- Calculate position on circle around anchor using the radius slider
            local x = math.sin(autoStrafeAngle) * autoStrafeRadius
            local z = math.cos(autoStrafeAngle) * autoStrafeRadius
            
            -- Target position on the circle
            local targetPos = autoStrafeAnchor + Vector3.new(x, 0, z)
            
            -- Move character toward target position
            local currentPos = Vector3.new(rootPart.Position.X, 0, rootPart.Position.Z)
            local direction = (Vector3.new(targetPos.X, 0, targetPos.Z) - currentPos)
            
            if direction.Magnitude > 0.1 then
                direction = direction.Unit
                
                -- Use actual walkspeed for velocity
                local speed = customWalkspeedEnabled and walkspeedValue or humanoid.WalkSpeed
                rootPart.Velocity = Vector3.new(
                    direction.X * speed * 3, -- Multiply by 3 for aggressive following
                    rootPart.Velocity.Y,
                    direction.Z * speed * 3
                )
            end
        else
            -- Reset anchor when disabled and destroy the part
            autoStrafeAnchor = nil
            if autoStrafeAnchorPart then
                autoStrafeAnchorPart:Destroy()
                autoStrafeAnchorPart = nil
            end
        end
        
        -- Force Shift Lock enforcement
        if forceShiftLockEnabled then
            pcall(function()
                if LocalPlayer.DevEnableMouseLock ~= true then
                    LocalPlayer.DevEnableMouseLock = true
                end
            end)
        end
        if airControlEnabled and humanoid and rootPart then
            local moveDir = humanoid.MoveDirection
            
            -- Check if in air (not on ground)
            if humanoid.FloorMaterial == Enum.Material.Air and moveDir.Magnitude > 0 then
                local wishDir = moveDir.Unit
                local hzVel = Vector3.new(rootPart.Velocity.X, 0, rootPart.Velocity.Z)
                local airSpeed = math.max(
                    bhopEnabled and bhopType == "advanced" and currSpeed or walkspeedValue,
                    hzVel.Magnitude
                )
                
                -- Instant snap to direction (no inertia, full air control)
                rootPart.Velocity = Vector3.new(
                    wishDir.X * airSpeed,
                    rootPart.Velocity.Y,
                    wishDir.Z * airSpeed
                )
            end
        end
        
        -- Anti-slide: Stop momentum when not moving
        if humanoid and rootPart and antiSlideEnabled and not airControlEnabled and not bhopEnabled then
            -- Check if player is not pressing any movement keys
            local moveVector = humanoid.MoveVector
            
            if moveVector.Magnitude == 0 then
                -- Player is not pressing any movement keys, kill horizontal velocity
                local velocity = rootPart.Velocity
                rootPart.Velocity = Vector3.new(0, velocity.Y, 0) -- Keep Y (jumping/falling) but zero out X and Z
            end
        end
    end
end)

-- ============================================
-- VISUAL TAB - ESP SYSTEM
-- ============================================

-- ESP Variables
local espEnabled = false
local nametagsEnabled = false
local espBoxColor = Color3.fromRGB(255, 0, 0)
local nametagColor = Color3.fromRGB(255, 255, 255)
local showDistance = false
local espObjects = {}
local espBoxSize = 1

-- ESP Section
local ESPSection = VisualTab:CreateSection({
    Name = "ESP"
})

ESPSection:AddToggle({
    Name = "Bounding Boxes",
    Flag = "ESP_BoundingBoxes",
    Callback = function(value)
        espEnabled = value
        if value then
            print("âœ“ ESP ENABLED")
            createESP()
        else
            print("âœ— ESP DISABLED")
            removeESP()
        end
    end
})

ESPSection:AddToggle({
    Name = "Nametags",
    Flag = "ESP_Nametags",
    Callback = function(value)
        nametagsEnabled = value
        if value then
            print("âœ“ Nametags ENABLED")
        else
            print("âœ— Nametags DISABLED")
        end
        if updateAllESP then updateAllESP() end
    end
})

ESPSection:AddToggle({
    Name = "Show Distance",
    Flag = "ESP_ShowDistance",
    Callback = function(value)
        showDistance = value
        if updateAllESP then updateAllESP() end
    end
})

-- ESP Settings Section
local ESPSettingsSection = VisualTab:CreateSection({
    Name = "ESP Settings",
    Side = "Right"
})

ESPSettingsSection:AddSlider({
    Name = "Box Size",
    Flag = "ESP_BoxSize",
    Value = 1,
    Min = 0.5,
    Max = 3,
    Precise = 1,
    Format = function(Value)
        return "Size: " .. tostring(Value) .. "x"
    end,
    Callback = function(value)
        espBoxSize = value
        if updateAllESP then
            if updateAllESP then updateAllESP() end
        end
    end
})

ESPSettingsSection:AddColorpicker({
    Name = "Box Color",
    Flag = "ESP_BoxColor",
    Value = Color3.fromRGB(255, 0, 0),
    Callback = function(value)
        espBoxColor = value
        if updateAllESP then updateAllESP() end
    end
})

ESPSettingsSection:AddColorpicker({
    Name = "Nametag Color",
    Flag = "ESP_NametagColor",
    Value = Color3.fromRGB(255, 255, 255),
    Callback = function(value)
        nametagColor = value
        if updateAllESP then updateAllESP() end
    end
})

-- ============================================
-- Function to fling something
local function flingTarget(target)
    if not target or not target:IsA("BasePart") then
        return
    end
    
    if target.Anchored then
        return
    end
    
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Velocity = Vector3.new(
        math.random(-FLING_POWER, FLING_POWER),
        FLING_POWER,
        math.random(-FLING_POWER, FLING_POWER)
    )
    bv.Parent = target
    
    task.delay(0.1, function()
        if bv and bv.Parent then
            bv:Destroy()
        end
    end)
end

-- ============================================
-- ESP FUNCTIONS
-- ============================================

-- Function to create a line between two points
local function createLine(parent)
    local line = Instance.new("Part")
    line.Anchored = true
    line.CanCollide = false
    line.Material = Enum.Material.Neon
    line.Size = Vector3.new(0.05, 0.05, 1)
    line.Parent = parent
    return line
end

-- Function to update a line between two points
local function updateLine(line, pointA, pointB, color)
    local distance = (pointA - pointB).Magnitude
    line.Size = Vector3.new(0.05, 0.05, distance)
    line.CFrame = CFrame.new(pointA, pointB) * CFrame.new(0, 0, -distance / 2)
    line.Color = color
end

-- Function to create 3D bounding box
local function create3DBox()
    local boxFolder = Instance.new("Folder")
    boxFolder.Name = "ESP_Box"
    
    -- Create 12 lines for a box (4 top, 4 bottom, 4 connecting)
    local lines = {}
    for i = 1, 12 do
        lines[i] = createLine(boxFolder)
    end
    
    return boxFolder, lines
end

-- Function to update 3D box around a character
update3DBox = function(lines, character, color)
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        for _, line in pairs(lines) do
            line.Transparency = 1
        end
        return
    end
    
    -- Get character size with multiplier
    local rootPart = character.HumanoidRootPart
    local sizeX, sizeY, sizeZ = 2.5 * espBoxSize, 5 * espBoxSize, 1.5 * espBoxSize
    
    -- Calculate corners
    local cf = rootPart.CFrame
    local corners = {
        -- Bottom 4 corners
        cf * CFrame.new(-sizeX/2, -sizeY/2, -sizeZ/2).Position,
        cf * CFrame.new(sizeX/2, -sizeY/2, -sizeZ/2).Position,
        cf * CFrame.new(sizeX/2, -sizeY/2, sizeZ/2).Position,
        cf * CFrame.new(-sizeX/2, -sizeY/2, sizeZ/2).Position,
        -- Top 4 corners
        cf * CFrame.new(-sizeX/2, sizeY/2, -sizeZ/2).Position,
        cf * CFrame.new(sizeX/2, sizeY/2, -sizeZ/2).Position,
        cf * CFrame.new(sizeX/2, sizeY/2, sizeZ/2).Position,
        cf * CFrame.new(-sizeX/2, sizeY/2, sizeZ/2).Position,
    }
    
    -- Update lines
    -- Bottom square
    updateLine(lines[1], corners[1], corners[2], color)
    updateLine(lines[2], corners[2], corners[3], color)
    updateLine(lines[3], corners[3], corners[4], color)
    updateLine(lines[4], corners[4], corners[1], color)
    
    -- Top square
    updateLine(lines[5], corners[5], corners[6], color)
    updateLine(lines[6], corners[6], corners[7], color)
    updateLine(lines[7], corners[7], corners[8], color)
    updateLine(lines[8], corners[8], corners[5], color)
    
    -- Connecting lines
    updateLine(lines[9], corners[1], corners[5], color)
    updateLine(lines[10], corners[2], corners[6], color)
    updateLine(lines[11], corners[3], corners[7], color)
    updateLine(lines[12], corners[4], corners[8], color)
    
    -- Set visibility
    for _, line in pairs(lines) do
        line.Transparency = 0
    end
end

-- Function to create ESP for a player
createPlayerESP = function(player)
    if player == LocalPlayer then return end
    if espObjects[player] then return end
    
    local espObject = {
        Player = player,
        BoxFolder = nil,
        BoxLines = nil,
        Nametag = nil
    }
    
    -- Create 3D Box
    local boxFolder, boxLines = create3DBox()
    boxFolder.Parent = workspace
    espObject.BoxFolder = boxFolder
    espObject.BoxLines = boxLines
    
    -- Create BillboardGui for nametag
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Nametag"
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.Name
    nameLabel.TextColor3 = nametagColor
    nameLabel.TextStrokeTransparency = 0.5
    nameLabel.Font = Enum.Font.Code
    nameLabel.TextSize = 16
    nameLabel.Parent = billboard
    
    espObject.Nametag = billboard
    
    espObjects[player] = espObject
    
    -- Function to update ESP
    local function updateESP()
        if not player.Character then
            for _, line in pairs(boxLines) do
                line.Transparency = 1
            end
            if billboard.Parent then billboard.Parent = nil end
            return
        end
        
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then
            for _, line in pairs(boxLines) do
                line.Transparency = 1
            end
            if billboard.Parent then billboard.Parent = nil end
            return
        end
        
        -- Update 3D box
        if espEnabled then
            update3DBox(boxLines, player.Character, espBoxColor)
        else
            for _, line in pairs(boxLines) do
                line.Transparency = 1
            end
        end
        
        -- Update nametag
        if nametagsEnabled and billboard then
            billboard.Parent = rootPart
            nameLabel.TextColor3 = nametagColor
            
            -- Update distance
            if showDistance and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                nameLabel.Text = player.Name .. "\n[" .. math.floor(distance) .. " studs]"
            else
                nameLabel.Text = player.Name
            end
        else
            billboard.Parent = nil
        end
    end
    
    -- Initial update
    updateESP()
    
    -- Connect to character added
    player.CharacterAdded:Connect(function()
        task.wait(0.5)
        updateESP()
    end)
    
    return espObject
end

-- Function to remove ESP for a player
removePlayerESP = function(player)
    if espObjects[player] then
        if espObjects[player].BoxFolder then
            espObjects[player].BoxFolder:Destroy()
        end
        if espObjects[player].Nametag then
            espObjects[player].Nametag:Destroy()
        end
        espObjects[player] = nil
    end
end

-- Function to create ESP for all players
function createESP()
    for _, player in pairs(Players:GetPlayers()) do
        createPlayerESP(player)
    end
end

-- Function to remove all ESP
function removeESP()
    for player, _ in pairs(espObjects) do
        removePlayerESP(player)
    end
end

-- Function to update all ESP (overwrites placeholder)
updateAllESP = function()
    for player, espObj in pairs(espObjects) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
            
            -- Update 3D box
            if espEnabled and espObj.BoxLines then
                update3DBox(espObj.BoxLines, player.Character, espBoxColor)
            else
                if espObj.BoxLines then
                    for _, line in pairs(espObj.BoxLines) do
                        line.Transparency = 1
                    end
                end
            end
            
            -- Update nametag
            if nametagsEnabled and espObj.Nametag then
                espObj.Nametag.Parent = rootPart
                local nameLabel = espObj.Nametag:FindFirstChildOfClass("TextLabel")
                if nameLabel then
                    nameLabel.TextColor3 = nametagColor
                    
                    if showDistance and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                        nameLabel.Text = player.Name .. "\n[" .. math.floor(distance) .. " studs]"
                    else
                        nameLabel.Text = player.Name
                    end
                end
            else
                if espObj.Nametag then espObj.Nametag.Parent = nil end
            end
        end
    end
end

-- Player added/removed events
Players.PlayerAdded:Connect(function(player)
    if espEnabled or nametagsEnabled then
        task.wait(1)
        createPlayerESP(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removePlayerESP(player)
end)

-- Update ESP loop
RunService.RenderStepped:Connect(function()
    if espEnabled then
        for player, espObj in pairs(espObjects) do
            if player.Character and espObj.BoxLines then
                update3DBox(espObj.BoxLines, player.Character, espBoxColor)
            end
        end
    end
    
    if nametagsEnabled then
        for player, espObj in pairs(espObjects) do
            if showDistance and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local nameLabel = espObj.Nametag and espObj.Nametag:FindFirstChildOfClass("TextLabel")
                if nameLabel and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local rootPart = player.Character.HumanoidRootPart
                    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                    nameLabel.Text = player.Name .. "\n[" .. math.floor(distance) .. " studs]"
                end
            end
        end
    end
end)

-- ============================================
-- AURA FUNCTIONS
-- ============================================

-- Function to create the aura ring
createAuraRing = function()
    -- Destroy old ring parts
    for _, part in pairs(auraRingParts) do
        if part then
            part:Destroy()
        end
    end
    auraRingParts = {}
    
    if not showAuraVisualization then
        return
    end
    
    repeat task.wait() until LocalPlayer.Character
    repeat task.wait() until LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    
    print("Creating aura ring...")
    
    if auraRingStyle == "solid" then
        -- Create a solid torus (donut shape) using a Part with a special mesh
        local solidRing = Instance.new("Part")
        solidRing.Name = "AuraRingSegment"
        solidRing.Shape = Enum.PartType.Ball
        solidRing.Size = Vector3.new(1, 1, 1)
        solidRing.Transparency = 0.3
        solidRing.Color = auraRingColor
        solidRing.Material = Enum.Material.Neon
        solidRing.CanCollide = false
        solidRing.Anchored = true
        solidRing.CastShadow = false
        solidRing.Parent = workspace
        
        -- Add a SpecialMesh to create the ring/torus shape  
        local mesh = Instance.new("SpecialMesh")
        mesh.MeshType = Enum.MeshType.FileMesh
        mesh.MeshId = "rbxassetid://3270017" -- Torus mesh
        mesh.Scale = Vector3.new(AURA_RADIUS * 0.4, auraRingThickness, AURA_RADIUS * 0.4)
        mesh.Parent = solidRing
        
        table.insert(auraRingParts, solidRing)
        print("âœ“ Solid aura ring created!")
    else
        -- Create ring using multiple cylinder parts arranged in a circle (dots style)
        local numSegments = 36
        local segmentAngle = (math.pi * 2) / numSegments
        
        for i = 1, numSegments do
            local angle = segmentAngle * i
            local segment = Instance.new("Part")
            segment.Name = "AuraRingSegment"
            segment.Shape = Enum.PartType.Cylinder
            segment.Size = Vector3.new(auraRingHeight, auraRingThickness, auraRingThickness)
            segment.Transparency = 0.3
            segment.Color = auraRingColor
            segment.Material = Enum.Material.Neon
            segment.CanCollide = false
            segment.Anchored = true
            segment.CastShadow = false
            segment.Parent = workspace
            
            table.insert(auraRingParts, segment)
        end
        print("âœ“ Aura ring created with", #auraRingParts, "segments! Style: dots")
    end
end

-- Function to update aura ring position and size
updateAuraRing = function()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        print("DEBUG: updateAuraRing - No character/root")
        return
    end
    
    if not showAuraVisualization then
        print("DEBUG: updateAuraRing - Visualization disabled")
        return
    end
    
    if #auraRingParts == 0 then
        print("DEBUG: updateAuraRing - No ring parts exist")
        return
    end
    
    print("DEBUG: Updating", #auraRingParts, "ring segments with radius", AURA_RADIUS)
    
    -- Update rotation if spinning is enabled
    if auraRingSpin then
        currentRotation = currentRotation + (0.02 * auraSpinSpeed)
        if currentRotation >= math.pi * 2 then
            currentRotation = 0
        end
    end
    
    local rootPart = LocalPlayer.Character.HumanoidRootPart
    local position = rootPart.Position - Vector3.new(0, rootPart.Size.Y / 2 + 2, 0)
    
    local numSegments = #auraRingParts
    local segmentAngle = (math.pi * 2) / numSegments
    
    if auraRingStyle == "solid" then
        -- Update solid ring (single torus mesh part)
        local solidRing = auraRingParts[1]
        if solidRing then
            solidRing.CFrame = CFrame.new(position) * CFrame.Angles(0, currentRotation, 0)
            solidRing.Color = auraRingColor
            
            -- Update mesh scale
            local mesh = solidRing:FindFirstChildOfClass("SpecialMesh")
            if mesh then
                mesh.Scale = Vector3.new(AURA_RADIUS * 0.4, auraRingThickness, AURA_RADIUS * 0.4)
            end
        end
    else
        -- Update dots ring (cylinder segments)
        for i, segment in pairs(auraRingParts) do
            if segment then
                local angle = segmentAngle * i + currentRotation
                local x = math.cos(angle) * AURA_RADIUS
                local z = math.sin(angle) * AURA_RADIUS
                
                local segmentPos = position + Vector3.new(x, 0, z)
                segment.CFrame = CFrame.new(segmentPos) * CFrame.Angles(0, angle, math.rad(90))
                segment.Size = Vector3.new(auraRingHeight, auraRingThickness, auraRingThickness)
                segment.Color = auraRingColor
            end
        end
    end
    
    print("DEBUG: Ring update complete!")
end

-- Function to create the aura
createAura = function()
    createAuraRing()
    
    print("Creating aura scanning system...")
    
    -- Active scanning
    local lastCheck = 0
    local recentlyFlung = {}
    
    auraConnection = RunService.RenderStepped:Connect(function()
        if not auraEnabled then return end
        
        if tick() - lastCheck < 0.2 then 
            updateAuraRing()
            return 
        end
        lastCheck = tick()
        
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local myPos = LocalPlayer.Character.HumanoidRootPart.Position
        
        -- Check all players
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                local theirRoot = player.Character:FindFirstChild("HumanoidRootPart")
                
                if humanoid and humanoid.Health > 0 and theirRoot then
                    local distance = (theirRoot.Position - myPos).Magnitude
                    
                    if distance <= AURA_RADIUS then
                        if not recentlyFlung[player] or tick() - recentlyFlung[player] > 1 then
                            print("ðŸŽ¯ FLINGING Player:", player.Name)
                            recentlyFlung[player] = tick()
                            
                            -- Set network ownership
                            local SetNetworkOwner = GrabEvents:FindFirstChild("SetNetworkOwner")
                            if SetNetworkOwner then
                                SetNetworkOwner:FireServer(theirRoot, theirRoot.CFrame)
                            end
                            
                            -- Create grab line
                            local myRoot = LocalPlayer.Character.HumanoidRootPart
                            local offsetCFrame = myRoot.CFrame:ToObjectSpace(theirRoot.CFrame)
                            CreateGrabLine:FireServer(theirRoot, offsetCFrame)
                            
                            task.wait(0.05)
                            flingTarget(theirRoot)
                        end
                    end
                end
            end
        end
        
        -- Check for parts
        local region = Region3.new(myPos - Vector3.new(AURA_RADIUS, AURA_RADIUS, AURA_RADIUS), 
                                    myPos + Vector3.new(AURA_RADIUS, AURA_RADIUS, AURA_RADIUS))
        region = region:ExpandToGrid(4)
        
        local parts = workspace:FindPartsInRegion3(region, LocalPlayer.Character, 100)
        
        for _, part in pairs(parts) do
            if part:IsA("BasePart") and not part.Anchored then
                if not part:IsDescendantOf(LocalPlayer.Character) and part.Name ~= "AuraRingSegment" then
                    local partDistance = (part.Position - myPos).Magnitude
                    
                    if partDistance <= AURA_RADIUS then
                        if not recentlyFlung[part] or tick() - recentlyFlung[part] > 1 then
                            recentlyFlung[part] = tick()
                            
                            local SetNetworkOwner = GrabEvents:FindFirstChild("SetNetworkOwner")
                            if SetNetworkOwner then
                                SetNetworkOwner:FireServer(part, part.CFrame)
                            end
                            
                            local myRoot = LocalPlayer.Character.HumanoidRootPart
                            local offsetCFrame = myRoot.CFrame:ToObjectSpace(part.CFrame)
                            CreateGrabLine:FireServer(part, offsetCFrame)
                            
                            task.wait(0.05)
                            flingTarget(part)
                        end
                    end
                end
            end
        end
        
        -- Update aura ring position
        updateAuraRing()
    end)
end

-- Function to destroy the aura
destroyAura = function()
    for _, part in pairs(auraRingParts) do
        if part then
            part:Destroy()
        end
    end
    auraRingParts = {}
    
    if auraConnection then
        auraConnection:Disconnect()
        auraConnection = nil
    end
    print("âœ— Aura destroyed")
end

-- Listen for instant fling (manual grabs)
CreateGrabLine.OnClientEvent:Connect(function(player, grabbedPart, offset)
    if player == LocalPlayer and instantFlingEnabled then
        print("ðŸŽ¯ Grabbed:", grabbedPart.Name)
        
        task.wait(0.05)
        
        -- Check if it's a player
        local character = grabbedPart.Parent
        if character and character:FindFirstChild("Humanoid") then
            local targetPlayer = Players:GetPlayerFromCharacter(character)
            if targetPlayer then
                print("ðŸŽ¯ This is player:", targetPlayer.Name)
                local theirRoot = character:FindFirstChild("HumanoidRootPart")
                if theirRoot then
                    flingTarget(theirRoot)
                end
                return
            end
        end
        
        flingTarget(grabbedPart)
    end
end)
